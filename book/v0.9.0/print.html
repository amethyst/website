<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Amethyst Documentation</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = default_theme; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li><a href="intro.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><a href="getting-started.html"><strong aria-hidden="true">2.</strong> Getting Started</a></li><li><a href="concepts/intro.html"><strong aria-hidden="true">3.</strong> Concepts</a></li><li><ol class="section"><li><a href="concepts/state.html"><strong aria-hidden="true">3.1.</strong> State</a></li><li><a href="concepts/component.html"><strong aria-hidden="true">3.2.</strong> Component</a></li><li><a href="concepts/entity.html"><strong aria-hidden="true">3.3.</strong> Entity</a></li><li><a href="concepts/resource.html"><strong aria-hidden="true">3.4.</strong> Resource</a></li><li><a href="concepts/world.html"><strong aria-hidden="true">3.5.</strong> World</a></li><li><a href="concepts/system.html"><strong aria-hidden="true">3.6.</strong> System</a></li><li><a href="concepts/dispatcher.html"><strong aria-hidden="true">3.7.</strong> Dispatcher</a></li><li><a href="concepts/event-channel.html"><strong aria-hidden="true">3.8.</strong> Event Channel</a></li></ol></li><li><a href="pong-tutorial.html"><strong aria-hidden="true">4.</strong> Pong Tutorial</a></li><li><ol class="section"><li><a href="pong-tutorial/pong-tutorial-01.html"><strong aria-hidden="true">4.1.</strong> Opening (and closing!) a window</a></li><li><a href="pong-tutorial/pong-tutorial-02.html"><strong aria-hidden="true">4.2.</strong> Drawing the paddles</a></li><li><a href="pong-tutorial/pong-tutorial-03.html"><strong aria-hidden="true">4.3.</strong> Moving the paddles</a></li><li><a href="pong-tutorial/contribution.html"><strong aria-hidden="true">4.4.</strong> Call for contribution</a></li></ol></li><li><a href="animation.html"><strong aria-hidden="true">5.</strong> Animation</a></li><li><ol class="section"><li><a href="animation/interpolation.html"><strong aria-hidden="true">5.1.</strong> Interpolation</a></li><li><a href="animation/channel.html"><strong aria-hidden="true">5.2.</strong> Channel</a></li><li><a href="animation/sampler.html"><strong aria-hidden="true">5.3.</strong> Sampler</a></li><li><a href="animation/definition.html"><strong aria-hidden="true">5.4.</strong> Definition</a></li></ol></li><li><a href="game-data.html"><strong aria-hidden="true">6.</strong> Custom GameData</a></li><li><a href="sprites.html"><strong aria-hidden="true">7.</strong> Sprites</a></li><li><ol class="section"><li><a href="sprites/set_up_the_render_pass.html"><strong aria-hidden="true">7.1.</strong> Set Up The Render Pass</a></li><li><a href="sprites/load_the_texture.html"><strong aria-hidden="true">7.2.</strong> Load The Texture</a></li><li><a href="sprites/define_the_sprite_sheet.html"><strong aria-hidden="true">7.3.</strong> Define The SpriteSheet</a></li><li><a href="sprites/sprite_render_component.html"><strong aria-hidden="true">7.4.</strong> SpriteRender Component</a></li><li><a href="sprites/orthographic_camera.html"><strong aria-hidden="true">7.5.</strong> Orthographic Camera</a></li></ol></li><li><a href="prefab.html"><strong aria-hidden="true">8.</strong> Prefabs</a></li><li><a href="glossary.html"><strong aria-hidden="true">9.</strong> Glossary</a></li><li><a href="appendices/a_config_files.html"><strong aria-hidden="true">10.</strong> Appendix A: Config Files</a></li><li><ol class="section"><li><a href="appendices/a_config_files/arena_config.html"><strong aria-hidden="true">10.1.</strong> Adding an Arena Config</a></li><li><a href="appendices/a_config_files/ball_config.html"><strong aria-hidden="true">10.2.</strong> Adding a Ball Config</a></li><li><a href="appendices/a_config_files/paddle_configs.html"><strong aria-hidden="true">10.3.</strong> Adding Paddle Configs</a></li></ol></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Amethyst Documentation</h1> 

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <div style="display:inline-block;width:100%">
    <img src="./images/amethyst_thumb.png" alt="Logo" width="96px" style="float:left;margin-right:15px"/>
    <a class="header" href="#the-amethyst-engine" id="the-amethyst-engine"><h1>The Amethyst Engine</h1></a>
</div>
<a class="header" href="#presentation" id="presentation"><h2>Presentation</h2></a>
<p>Howdy! This book will teach you everything you need to know about building video
games and interactive simulations with the Amethyst game engine. This engine is
written entirely in <a href="https://www.rust-lang.org/">Rust</a>, a safe and fast systems programming language,
and sports a clean and modern design. More correctly, though, Amethyst is
actually a collection of separate libraries and tools that collectively make up a
game engine.</p>
<p>Amethyst is free and open source software, distributed under a dual license of <a href="https://github.com/amethyst/amethyst/blob/master/docs/LICENSE-MIT">MIT</a>
and <a href="https://github.com/amethyst/amethyst/blob/master/docs/LICENSE-APACHE">Apache</a>. This means that the engine is given to you at no cost
and its source code is completely yours to tinker with. The code is available on
<a href="https://github.com/amethyst/amethyst/tree/master">GitHub</a>. Contributions and feature requests will always be welcomed!</p>
<a class="header" href="#getting-started" id="getting-started"><h2>Getting started</h2></a>
<p>This book is split into several sections, with this introduction being the first. The others are:</p>
<ul>
<li><a href="./getting-started.html">Getting Started</a> – Prepare your computer for Amethyst development.</li>
<li><a href="./concepts/intro.html">Concepts</a> – An overview of the concepts used in Amethyst. Recommended.</li>
<li><a href="./pong-tutorial.html">Pong Tutorial</a> – Build a basic pong game in Rust.</li>
<li><a href="./animation.html">Animation</a> – Explains the architecture of the <code>amethyst_animation</code> crate.</li>
<li><a href="./game-data.html">Custom <code>GameData</code></a> – Shows you how to structure more complex games that need to change the system graph.</li>
<li><a href="./glossary.html">Glossary</a> – Defines special terms used throughout the book.</li>
<li><a href="./appendices/a_config_files.html">Appendix A: Config Files</a> – Shows you how to define your data in RON files.</li>
</ul>
<p>Read the crate-level <a href="https://www.amethyst.rs/doc/master/doc/amethyst/index.html">API documentation</a> for more details.</p>
<a class="header" href="#motivation" id="motivation"><h2>Motivation</h2></a>
<p>Most of us have worked with quite a few game engines over the years, namely <a href="http://unity3d.com/">Unity</a>, <a href="https://www.unrealengine.com/">Unreal Engine</a>, <a href="http://jmonkeyengine.org/">JMonkeyEngine</a> and many more.
While they all are pretty solid solutions if you want to
build a quality game, each have their own pros and cons that you have to
weigh before using them, especially in regards to performance and scalability.</p>
<p>We think that basing the Amethyst engine on good and modern principles will allow us to make an open source game engine that can actually be more performant than those engines.
Those principles are:</p>
<ol>
<li>
<p>Modularity.</p>
<p>Modularity is at the core of the <a href="https://en.wikipedia.org/wiki/Unix_philosophy">Unix philosophy</a>, which proved itself to be an excellent way of developing software over the years.
You will always be free to use the built-in modules, or to write your own and integrate them easily into the engine.
Since modules are small and well integrated, it is easier to reason about what they do and how they relate to other modules.</p>
</li>
<li>
<p>Parallelism.</p>
<p>Modern computers, even cheap ones, all have multithreading with multicore CPUs. We expect that over the years, there will be more and more opportunities for parallelism to improve performance.
With a proper parallel engine, we are convinced that your game will be more and more performant over the years without even needing you to update it.</p>
</li>
<li>
<p>Data-oriented/Data-driven.</p>
<p>Building your game around the data makes it really easy to prototype and quickly build a game.
Complex behaviours like swapping assets during gameplay become a breeze, making testing and balancing a lot faster.</p>
</li>
</ol>
<a class="header" href="#why-use-amethyst" id="why-use-amethyst"><h2>Why use Amethyst?</h2></a>
<p>While there are a lot of <a href="http://arewegameyet.com/">great building blocks</a> in the Rust ecosystem, using the Amethyst engine instead of building your own game engine definitely has a lot of advantages.</p>
<p>First of all, the engine is based on the <a href="https://github.com/slide-rs/specs">Specs</a> library, which is a common base on which the engine's concepts are built. Those are described in the <a href="./concepts/intro.html">concepts</a> section of the book.
A lot of features have been glued together using those:</p>
<p>There are the obvious ones:</p>
<ul>
<li>Transformations</li>
<li>Graphics</li>
<li>Windowing</li>
<li>Inputs</li>
<li>Audio</li>
<li>Etc...</li>
</ul>
<p>And also the less known but also essential features:</p>
<ul>
<li>Animations</li>
<li>Gltf</li>
<li>Locales</li>
<li>Networking</li>
</ul>
<p>If you were not to use Amethyst, not only would you need to create all those features (or use pre-existing crates), but you would also need to glue the layers together.</p>
<p>Amethyst does all of this for you, so that you can focus on making your game instead of worrying about the low-level details.</p>
<p>Futhermore, because of the architecture of Amethyst, almost all the parts are both configurable and replaceable. This means that if you do want to change something to suit your needs, there's always a way to do it.</p>
<p>For example, the <a href="https://github.com/tomaka/rodio">rodio</a> crate is currently used for the audio features in the engine, but if you would rather use something more complex or a custom solution, all you have to do is add some glue that moves the data coming from Specs into the library that you are using to play and control the audio, without even having to touch the engine code!</p>
<a class="header" href="#contributing" id="contributing"><h2>Contributing</h2></a>
<p>We are always happy to welcome new contributors!</p>
<p>To know where to start, we suggest you read our <a href="https://github.com/amethyst/amethyst/blob/master/docs/CONTRIBUTING.md">contribution guidelines</a></p>
<p>If you want to contribute, or have questions, let us know either on <a href="https://github.com/amethyst/amethyst/">GitHub</a>, or on <a href="https://discord.gg/GnP5Whs">Discord</a>.</p>
<a class="header" href="#getting-started-1" id="getting-started-1"><h1>Getting started</h1></a>
<a class="header" href="#setting-up-rust" id="setting-up-rust"><h2>Setting up Rust</h2></a>
<p>We recommend using <a href="https://rustup.rs">rustup</a> to easily install the latest stable version of rust.
Instructions should be on screen once rustup is downloaded.</p>
<a class="header" href="#required-dependencies" id="required-dependencies"><h2>Required dependencies</h2></a>
<p>If you are on Linux, you'll need to install <code>libasound2-dev</code>, <code>libx11-xcb-dev</code> and <code>libssl-dev</code>.</p>
<p>See the readme on github for distribution specific details.</p>
<a class="header" href="#setting-up-amethyst" id="setting-up-amethyst"><h2>Setting up Amethyst</h2></a>
<p>You can either use the <a href="https://github.com/amethyst/tools">Amethyst CLI</a> or cargo to set up your project.</p>
<a class="header" href="#amethyst-cli-easiest" id="amethyst-cli-easiest"><h3>Amethyst CLI (Easiest)</h3></a>
<p>If you wish to use the Amethyst cli tool, you can install it like so</p>
<pre><code class="language-norun">cargo install amethyst_tools
</code></pre>
<p>and then run</p>
<pre><code class="language-norun">amethyst new &lt;game-name&gt;
</code></pre>
<p>you should get <code>Cargo.toml</code>, <code>src/main.rs</code> and <code>resources/display_config.ron</code>.</p>
<a class="header" href="#cargo-manual" id="cargo-manual"><h3>Cargo (Manual)</h3></a>
<p>In case you're doing this with <code>cargo</code>, here's what you need to do:</p>
<ul>
<li>Add <code>amethyst</code> as dependency in your <code>Cargo.toml</code>.</li>
<li>Create a <code>resources</code> folder and put a <code>display_config.ron</code> in it.</li>
<li>(Optional) Copy the code from one of amethyst's examples.</li>
</ul>
<a class="header" href="#important-note-on-versioning" id="important-note-on-versioning"><h3>Important note on versioning</h3></a>
<p>Amethyst is divided in two major versions:</p>
<ul>
<li>The Release version, which is the latest version available on crates.io</li>
<li>The Git version, which is the unreleased future version of Amethyst available on <a href="https://github.com/amethyst/amethyst">Github</a></li>
</ul>
<p>Depending on the book version that you choose to read, make sure that the amethyst version in your Cargo.toml matches that.</p>
<p>For the Release version, you should have something like this:</p>
<pre><code class="language-rust ignore">[dependencies]
amethyst = &quot;LATEST_CRATES.IO_VERSION&quot;
</code></pre>
<p>The latest crates.io version can be found <a href="https://crates.io/crates/amethyst">here</a>.</p>
<p>If you want to use the latest unreleased changes, your Cargo.toml file should look like this:</p>
<pre><code class="language-rust ignore">[dependencies]
amethyst = { git = &quot;https://github.com/amethyst/amethyst&quot;, rev = &quot;COMMIT_HASH&quot; }
</code></pre>
<p>The commit hash part is optional. It indicates which specific commit your project uses, to prevent unexpected breakage when we make changes to the git version.</p>
<a class="header" href="#concepts-behind-amethyst" id="concepts-behind-amethyst"><h1>Concepts behind Amethyst</h1></a>
<p>Amethyst uses quite a few concepts that you might not be familiar with.
This section of the book explains what they are, how they work and
how they relate to each other.</p>
<p>If you are a practical person and want to quickly get into the code, you can skip to the <a href="../pong-tutorial.html">pong tutorial</a>
section of the book, which is focused on practice.
That said, reading this section is suggested, as it can be hard to understand the examples without knowing the theory presented here.</p>
<p>If you don't understand how something works in amethyst, knowing the concepts presented here will help you understand how some implementations are made.</p>
<a class="header" href="#chapters" id="chapters"><h2>Chapters</h2></a>
<ul>
<li><a href="./state.html">State</a></li>
<li><a href="./component.html">Component</a></li>
<li><a href="./entity.html">Entity</a></li>
<li><a href="./resource.html">Resource</a></li>
<li><a href="./world.html">World</a></li>
<li><a href="./system.html">System</a></li>
<li><a href="./dispatcher.html">Dispatcher</a></li>
<li><a href="./event-channel.html">EventChannel</a></li>
</ul>
<a class="header" href="#state" id="state"><h1>State</h1></a>
<a class="header" href="#what-is-a-state" id="what-is-a-state"><h2>What is a state?</h2></a>
<p>The word &quot;state&quot; can mean a lot of different things in computer science.
In the case of amethyst, it is used to represent the &quot;game stage&quot;.</p>
<p>A game stage is a <em>general</em> and <em>global</em> section of the game.</p>
<a class="header" href="#example" id="example"><h2>Example</h2></a>
<p>As an example, let's say you are making a pong game.</p>
<ul>
<li>When the user opens up the game, it first loads all the assets and shows a loading screen.</li>
<li>Then, the main menu shows up, asking you if you want to start a game in single or multiplayer.</li>
<li>Once you select an option, the game displays the paddles and the ball and starts playing.</li>
<li>By pressing escape, you can toggle the &quot;pause&quot; menu.</li>
<li>Once the score limit is reached, a result screen is shown with a button to go back to the main menu.</li>
</ul>
<p>The game can be divided into different states:</p>
<ul>
<li>LoadingState</li>
<li>MainMenuState</li>
<li>GameplayState</li>
<li>PauseState</li>
<li>ResultState</li>
</ul>
<p>While you could effectively insert all the game's logic into a single state <code>GameState</code>,
dividing it into multiple parts makes it much easier to reason about and maintain.</p>
<a class="header" href="#state-manager" id="state-manager"><h2>State Manager</h2></a>
<p>Amethyst has a built-in state manager, which allows easily switching between different <code>State</code>s.
It is based on the concept of a pushdown-automaton, which is a combination of a Stack and a State Machine.</p>
<a class="header" href="#stack" id="stack"><h3>Stack</h3></a>
<p>The stack concept makes it so you can &quot;push&quot; <code>State</code>s on top of each other.</p>
<p>If we take the pong example of earlier, you can push the <code>PauseState</code> over the <code>GameplayState</code>.</p>
<p>When you want to go out of pause, you pop the <code>PauseState</code> out of the stack and you are back into the <code>GameplayState</code>, just as you left it.</p>
<a class="header" href="#state-machine" id="state-machine"><h3>State Machine</h3></a>
<p>The concept of State Machine can be pretty complex, but here we will only explain the basics of it.
The State Machine is usually composed of two elements: Transitions and Events.</p>
<p>Transitions are simply the &quot;switching&quot; between two states.</p>
<p>For example, from <code>LoadingState</code>, go to state <code>MainMenuState</code>.</p>
<p>Amethyst has multiple types of transitions.</p>
<ul>
<li>You can Push a <code>State</code> over another.</li>
<li>You can also Switch a <code>State</code>, which replaces the current <code>State</code> with a new one.</li>
</ul>
<p>Events are what trigger the transitions. In the case of amethyst, it is the different methods called on the <code>State</code>. Continue reading to learn about them.</p>
<a class="header" href="#life-cycle" id="life-cycle"><h2>Life Cycle</h2></a>
<p><code>State</code>s are only valid for a certain period of time, during which a lot of things can occur.
A <code>State</code> contains methods that reflect the most common of those events:</p>
<ul>
<li>on_start: When a <code>State</code> is added to the stack, this method is called on it.</li>
<li>on_stop: When a <code>State</code> is removed from the stack, this method is called on it.</li>
<li>on_pause: When a <code>State</code> is pushed over the current one, the current one is paused, and this method is called on it.</li>
<li>on_resume: When the <code>State</code> that was pushed over the current <code>State</code> is popped, the current one resumes, and this method is called on the now-current <code>State</code>.</li>
<li>handle_event: Allows easily handling events, like the window closing or a key being pressed.</li>
<li>fixed_update: This method is called on the active <code>State</code> at a fixed time interval (1/60th second by default).</li>
<li>update: This method is called on the active <code>State</code> as often as possible by the engine.</li>
<li>shadow_update: This method is called as often as possible by the engine on all <code>State</code>s which are on the <code>StateMachines</code> stack, including the active <code>State</code>. Unlike <code>update</code>, this does not return a <code>Trans</code>.</li>
<li>shadow_fixed_update: This method is called at a fixed time interval (1/60th second by default) on all <code>State</code>s which are on the <code>StateMachines</code> stack, including the active <code>State</code>. Unlike <code>fixed_update</code>, this does not return a <code>Trans</code>.</li>
</ul>
<a class="header" href="#game-data" id="game-data"><h2>Game Data</h2></a>
<p><code>State</code>s can have arbitrary data associated with them.
If you need to store data that is tightly coupled to your <code>State</code>, the classic way is to put it in the <code>State</code>'s struct.</p>
<p><code>State</code>s also have internal data, which is any type T.
In most cases, the two following are the most used: <code>()</code> and <code>GameData</code>.</p>
<p><code>()</code> means that there is no data associated with this <code>State</code>. This is usually used for tests and not for actual games.
<code>GameData</code> is the de-facto standard. It is a struct containing a <code>Dispatcher</code>. This will be discussed later.</p>
<p>When calling your <code>State</code>'s methods, the engine will pass a <code>StateData</code> struct which contains both the <code>World</code> (which will also be discussed later) and the Game Data type that you chose.</p>
<a class="header" href="#code" id="code"><h2>Code</h2></a>
<p>Yes! It's finally time to get some code in here!</p>
<p>Here will just be a small code snippet that shows the basics of <code>State</code>'s usage.
For more advanced examples, see the following pong tutorial.</p>
<a class="header" href="#creating-a-state" id="creating-a-state"><h3>Creating a State</h3></a>
<pre><code class="language-rust no_run noplaypen">extern crate amethyst;
use amethyst::prelude::*;

struct GameplayState {
    /// The `State`-local data. Usually you will not have anything.
    /// In this case, we have the number of players here.
    player_count: u8,
}

impl&lt;'a,'b&gt; SimpleState&lt;'a,'b&gt; for GameplayState {
    fn on_start(&amp;mut self, _data: StateData&lt;GameData&gt;) {
        println!(&quot;Number of players: {}&quot;, self.player_count);
    }
}
</code></pre>
<p>That's a lot of code, indeed!</p>
<p>We first declare the <code>State</code>'s struct <code>GameplayState</code>.</p>
<p>In this case, we give it some data: <code>player_count</code>, a byte.</p>
<p>Then, we implement the <code>SimpleState</code> trait for our <code>GameplayState</code>.
<code>SimpleState</code> is a shorthand for <code>State&lt;GameData&lt;'a, 'b&gt;, ()&gt;</code> where <code>GameData</code> is the internal shared data between states.</p>
<a class="header" href="#switching-state" id="switching-state"><h3>Switching State</h3></a>
<p>Now, if we want to change to a second state, how do we do it?</p>
<p>Well, we'll need to use one of the methods that return the <code>Trans</code> type.</p>
<p>Those are:</p>
<ul>
<li><code>handle_event</code></li>
<li><code>fixed_update</code></li>
<li><code>update</code></li>
</ul>
<p>Let's use handle_event to go to the <code>PausedState</code> and come back by pressing the &quot;Escape&quot; key.</p>
<pre><code class="language-rust no_run noplaypen">extern crate amethyst;
use amethyst::prelude::*;
use amethyst::renderer::VirtualKeyCode;
use amethyst::input::is_key_down;

struct GameplayState;
struct PausedState;

// This time around, we are using () instead of GameData, because we don't have any `System`s that need to be updated.
// (They are covered in the dedicated section of the book.)
// Instead of writing `State&lt;(), StateEvent&gt;`, we can instead use `EmptyState`.
impl EmptyState for GameplayState {
    fn handle_event(&amp;mut self, _data: StateData&lt;()&gt;, event: StateEvent) -&gt; EmptyTrans {
        if let StateEvent::Window(event) = &amp;event {
            if is_key_down(&amp;event, VirtualKeyCode::Escape) {
                // Pause the game by going to the `PausedState`.
                return Trans::Push(Box::new(PausedState));
            }
        }
        
        // Escape isn't pressed, so we stay in this `State`.
        Trans::None
    }
}

impl EmptyState for PausedState {
    fn handle_event(&amp;mut self, _data: StateData&lt;()&gt;, event: StateEvent) -&gt; EmptyTrans {
        if let StateEvent::Window(event) = &amp;event {
            if is_key_down(&amp;event, VirtualKeyCode::Escape) {
                // Go back to the `GameplayState`.
                return Trans::Pop;
            }
        }
        
        // Escape isn't pressed, so we stay in this `State`.
        Trans::None
    }
}
</code></pre>
<a class="header" href="#event-handling" id="event-handling"><h3>Event Handling</h3></a>
<p>As you already saw, we can handle events from the <code>handle_event</code> method.
But what is this weird <code>StateEvent</code> all about?</p>
<p>Well, it is simply an enum. It regroups multiple types of events that are emitted throughout the engine by default.
To change the set of events that the state receives, you create a new event enum and derive <code>EventReader</code> for that type.</p>
<pre><code class="language-rust no_run noplaypen"># #[macro_use] extern crate amethyst;
# use amethyst::prelude::*;
# use amethyst::renderer::{VirtualKeyCode, Event};
# use amethyst::ui::UiEvent;
# use amethyst::input::is_key_down;

// These imports are required for the #[derive(EventReader)] code to build
use amethyst::core::{
    specs::{Read, SystemData, Resources}, 
    shrev::{ReaderId, EventChannel}, 
    EventReader
};

#[derive(Clone, Debug)]
pub struct AppEvent {
    data: i32,
}

#[derive(Debug, EventReader, Clone)]
#[reader(MyEventReader)]
pub enum MyEvent {
    Window(Event),
    Ui(UiEvent),
    App(AppEvent),
}

struct GameplayState;

impl State&lt;(), MyEvent&gt; for GameplayState {
    fn handle_event(&amp;mut self, _data: StateData&lt;()&gt;, event: MyEvent) -&gt; Trans&lt;(), MyEvent&gt; {
        match event {
            MyEvent::Window(_) =&gt; {}, // Events related to the window and inputs.
            MyEvent::Ui(_) =&gt; {}, // Ui event. Button presses, mouse hover, etc...
            MyEvent::App(ev) =&gt; println!(&quot;Got an app event: {:?}&quot;, ev),
        };
        
        Trans::None
    }
}

# fn main() {}
</code></pre>
<p>To make <code>Application</code> aware of the change to which events to send to the state, you also need to supply both the
event type, and the <code>EventReader</code> type (the name you give in the <code>#[reader(SomeReader)]</code> derive attribute) when
the <code>Application</code> is created. This is done by replacing <code>Application::build</code> (or <code>Application::new</code>) with
<code>CoreApplication::&lt;_, MyEvent, MyEventReader&gt;::build()</code> (or <code>CoreApplication::&lt;_, MyEvent, MyEventReader&gt;::new()</code>).</p>
<p><em>Note: Events are gathered from <code>EventChannel</code>s. <code>EventChannel</code>s are covered in the dedicated book section.</em></p>
<a class="header" href="#component" id="component"><h1>Component</h1></a>
<a class="header" href="#what-is-a-component" id="what-is-a-component"><h2>What is a <code>Component</code>?</h2></a>
<p>A component is any struct that can be &quot;attached&quot; to an <code>Entity</code> (which we will cover in the next chapter).</p>
<a class="header" href="#usage" id="usage"><h2>Usage</h2></a>
<p>The relationship between an entity and a component closely resembles the relation between a real-life object and its properties.</p>
<p>For example, a bottle of water has a shape, a volume, a color and is made of a material (usually plastic).</p>
<p>In this example, the bottle is the entity, and the properties are components.</p>
<a class="header" href="#creating-a-component" id="creating-a-component"><h2>Creating a component</h2></a>
<p>Creating a component is easy.</p>
<p>You declare the relevant underlying data:</p>
<pre><code class="language-rust no_run noplaypen">/// This `Component` describes the shape of an `Entity`
enum Shape {
    Sphere { radius: f32 },
    RectangularPrism { height: f32, width: f32, depth: f32 },
}

/// This `Component` describes the contents of an `Entity`
pub struct Content {
    content_name: String,
}
</code></pre>
<p>and then you implement the <code>Component</code> trait for them:</p>
<pre><code class="language-rust no_run noplaypen"># extern crate amethyst;
# struct Shape;
# struct Content;
use amethyst::ecs::{Component, DenseVecStorage};

impl Component for Shape {
    type Storage = DenseVecStorage&lt;Self&gt;;
}

impl Component for Content {
    type Storage = DenseVecStorage&lt;Self&gt;;
}
</code></pre>
<a class="header" href="#storages" id="storages"><h2>Storages</h2></a>
<p><code>Component</code>s, in contrast with popular belief, should not be stored directly inside of an <code>Entity</code>.</p>
<p>They are instead stored in different types of <code>Storage</code>, which all have different performance strategies.</p>
<p>When implementing <code>Component</code> for a type, you have to specify which storage strategy it should use.</p>
<p>Here's a comparison of the most used ones:</p>
<ul>
<li><code>DenseVecStorage</code>: Elements are stored in a contiguous array. No empty space is left between <code>Component</code>s,
allowing a lowered memory usage for big components.</li>
<li><code>VecStorage</code>: Elements are stored into a sparse array. If your component is small (&lt;= 16 bytes) or is carried by most
entities, this is preferable over <code>DenseVecStorage</code>.</li>
<li><code>FlaggedStorage</code>: Used to keep track of changes of a component. Useful for caching purposes.</li>
</ul>
<p>For more information, see the <a href="https://docs.rs/specs/latest/specs/storage/index.html">specs storage reference</a>.</p>
<p>There are a bunch more storages, and deciding which one is the best isn't trivial and should be done based on careful
benchmarking. If you don't know which one you should use, <code>DenseVecStorage</code> is a good default. It will need more memory
than <code>VecStorage</code> for pointer-sized components, but it will perform well for most scenarios.</p>
<a class="header" href="#tags" id="tags"><h2>Tags</h2></a>
<p>Components can also be used to &quot;tag&quot; entities.
The usual way to do it is to create an empty struct, and implement <code>Component</code> using <code>NullStorage</code> as the <code>Storage</code> type for it.
Null storage means that it is not going to take memory space to store those components.</p>
<p>You will learn how to use those tag components in the system chapter.</p>
<a class="header" href="#entity" id="entity"><h1>Entity</h1></a>
<a class="header" href="#what-is-an-entity" id="what-is-an-entity"><h2>What is an entity?</h2></a>
<p>An <code>Entity</code> is simply a collection of <code>Component</code>s. At least conceptually. It represents a single object in your world.
For example, a car could be an entity, with its properties being <code>Component</code>s.</p>
<a class="header" href="#creating-an-entity" id="creating-an-entity"><h2>Creating an entity</h2></a>
<p>There are two common ways to create entities:</p>
<ul>
<li>From a <code>World</code> instance. See the relevant chapter in the book.</li>
<li>From a <code>System</code> using <code>Entities</code>. See the system chapter in the book.</li>
</ul>
<a class="header" href="#getting-components-of-an-entity" id="getting-components-of-an-entity"><h2>Getting components of an entity</h2></a>
<p>You can't! Well, at least not directly from an <code>Entity</code> instance.
As mentioned in the component book page, <code>Component</code>s are not directly attached to entities; they are inserted into storages.</p>
<p><code>Storage</code> access and modification will be covered in the resource, world and system sections of the book.</p>
<a class="header" href="#resource" id="resource"><h1>Resource</h1></a>
<a class="header" href="#what-is-a-resource" id="what-is-a-resource"><h2>What is a resource?</h2></a>
<p>A <code>Resource</code> is any type that stores data that you might need for your game AND that is not specific to an entity.
For example, the score of a pong game is global to the whole game and isn't owned by any of the entities (paddle, ball and even the ui score text).</p>
<a class="header" href="#creating-a-resource" id="creating-a-resource"><h2>Creating a resource</h2></a>
<p>Resources are stored in a, well, <code>Resources</code> type. This type is usually stored into a <code>World</code> instance, which is covered in the next chapter.
Normally you don't create a <code>Resources</code> instance yourself. It is usually made by amethyst automatically.</p>
<p>Adding a resource to a <code>Resources</code> instance is done like this:</p>
<pre><code class="language-rust no_run noplaypen"># extern crate amethyst;
use amethyst::ecs::{Resources};

struct MyResource {
    pub game_score: i32,
}

fn main() {
    let mut resources = Resources::new();
    
    let my = MyResource {
        game_score: 0,
    };
    
    resources.insert(my);
}
</code></pre>
<a class="header" href="#fetching-a-resource-from-resources" id="fetching-a-resource-from-resources"><h2>Fetching a resource (from <code>Resources</code>)</h2></a>
<p>Fetching a resource can be done like this:</p>
<pre><code class="language-rust no_run noplaypen"># extern crate amethyst;
# use amethyst::ecs::{Resources};
# struct MyResource;
# fn main() {
#   let mut resources = Resources::new();
// Returns a Option&lt;MyResource&gt;
let fetched = resources.try_fetch::&lt;MyResource&gt;().expect(&quot;No MyResource present in Resources&quot;);
# }
</code></pre>
<p>If you want to get a resource and create it if it doesn't exist:</p>
<pre><code class="language-rust no_run noplaypen"># extern crate amethyst;
# use amethyst::ecs::{Resources};
# struct MyResource;
# fn main() {
#   let mut resources = Resources::new();
#   let my = MyResource;
// If the resource isn't inside `Resources`, it will insert the instance we created earlier.
let fetched = resources.entry::&lt;MyResource&gt;().or_insert_with(|| my);
# }
</code></pre>
<p>If you want to change a resource that is already inside of <code>Resources</code>:</p>
<pre><code class="language-rust no_run noplaypen"># extern crate amethyst;
# use amethyst::ecs::{Resources};
# struct MyResource;
# fn main() {
#   let mut resources = Resources::new();
let mut fetched = resources.try_fetch_mut::&lt;MyResource&gt;().expect(&quot;No MyResource present in Resources&quot;);
# }
</code></pre>
<p>Other ways of fetching a resource will be covered in the system section of the book.</p>
<a class="header" href="#deleting-a-resource" id="deleting-a-resource"><h2>Deleting a resource</h2></a>
<p>There is no method to properly &quot;delete&quot; a resource added to the world.
The usual method to achieve something similar is to add an <code>Option&lt;MyResource&gt;</code> and to set it to <code>None</code> when you want to delete it.</p>
<a class="header" href="#storages-part-2" id="storages-part-2"><h2>Storages, part 2</h2></a>
<p>A <code>Component</code>'s <code>Storage</code> is a resource.
The components are &quot;attached&quot; to entities, but as said previously, they are not &quot;owned&quot; by the entities at the implementation level.
By storing them into <code>Storage</code>s and by having <code>Storage</code> be placed inside <code>Resources</code>,
it allows global access to all of the components at runtime with minimal effort.</p>
<p>Actually accessing the components inside <code>Storage</code>s will be covered in the world and system sections of the book.</p>
<p><strong>WARNING:</strong>
If you try to fetch the component directly, you will not get the storage. You will get a <code>Default::default()</code> instance of that component.
To get the <code>Storage</code> resource that HOLDS all the <code>MyComponent</code> instances, you need to fetch <code>ReadStorage&lt;MyComponent&gt;</code>.</p>
<a class="header" href="#world" id="world"><h1>World</h1></a>
<a class="header" href="#what-is-a-world" id="what-is-a-world"><h2>What is a world?</h2></a>
<p>A world is just a holder for <code>Resources</code>, with some helper functions that make your life easier.
This chapter will showcase those functions and their usage.</p>
<a class="header" href="#adding-a-resource" id="adding-a-resource"><h2>Adding a resource</h2></a>
<pre><code class="language-rust no_run noplaypen"># extern crate amethyst;
use amethyst::ecs::World;

// A simple struct with no data.
struct MyResource;

fn main() {
    // We create a new `World` instance.
    let mut world = World::new();
    
    // We create our resource.
    let my = MyResource;
    
    // We add the resource to the world.
    world.add_resource(my);
}
</code></pre>
<a class="header" href="#fetching-a-resource" id="fetching-a-resource"><h2>Fetching a resource</h2></a>
<p>Here's how to fetch a read-only resource. Be aware that this method panics if the resource isn't inserted into <code>Resources</code>.</p>
<pre><code class="language-rust no_run noplaypen"># extern crate amethyst;
# struct MyResource;
# fn main() {
#   let mut world = amethyst::ecs::World::new();
    let my = world.read_resource::&lt;MyResource&gt;();
# }
</code></pre>
<p>If you are not sure that the resource will be present, use the methods available on <code>Resources</code>, as shown in the resource chapter.</p>
<pre><code class="language-rust no_run noplaypen"># extern crate amethyst;
# struct MyResource;
# fn main() {
#   let mut world = amethyst::ecs::World::new();
    let my = world.res.entry::&lt;MyResource&gt;().or_insert_with(|| MyResource);
# }
</code></pre>
<a class="header" href="#modifying-a-resource" id="modifying-a-resource"><h2>Modifying a resource</h2></a>
<pre><code class="language-rust no_run noplaypen"># extern crate amethyst;
# struct MyResource;
# fn main() {
#   let mut world = amethyst::ecs::World::new();
    let mut my = world.write_resource::&lt;MyResource&gt;();
# }
</code></pre>
<a class="header" href="#creating-entities" id="creating-entities"><h2>Creating entities</h2></a>
<p>You first start by creating the entity builder.
Then, you can add components to your entity.
Finally, you call the build() method on the entity builder to get the actual entity.
Please note that <strong>in order to use this syntax, you need to import the <code>amethyst::prelude::Builder</code> trait.</strong></p>
<pre><code class="language-rust no_run noplaypen"># extern crate amethyst;
# struct MyComponent;
# impl amethyst::ecs::Component for MyComponent {
#   type Storage = amethyst::ecs::VecStorage&lt;MyComponent&gt;;
# }
# fn main() {
#   let mut world = amethyst::ecs::World::new();
    use amethyst::prelude::Builder;

    let mut entity_builder = world.create_entity();
    entity_builder = entity_builder.with(MyComponent);
    let my_entity = entity_builder.build();
# }
</code></pre>
<p>Shorter version:</p>
<pre><code class="language-rust no_run noplaypen"># extern crate amethyst;
# struct MyComponent;
# impl amethyst::ecs::Component for MyComponent {
#   type Storage = amethyst::ecs::VecStorage&lt;MyComponent&gt;;
# }
# fn main() {
#   let mut world = amethyst::ecs::World::new();
    use amethyst::prelude::Builder;

    let my_entity = world
       .create_entity()
       .with(MyComponent)
       .build();
# }
</code></pre>
<p>Internally, the <code>World</code> interacts with <code>EntitiesRes</code>, which is a resource holding the entities inside of <code>Resources</code>.</p>
<a class="header" href="#accessing-a-component" id="accessing-a-component"><h2>Accessing a <code>Component</code></h2></a>
<pre><code class="language-rust no_run noplaypen"># extern crate amethyst;
# use amethyst::prelude::Builder;
# struct MyComponent;
# impl amethyst::ecs::Component for MyComponent {
#   type Storage = amethyst::ecs::VecStorage&lt;MyComponent&gt;;
# }
# fn main() {
#   let mut world = amethyst::ecs::World::new();
    // Create an `Entity` with `MyComponent`.
    // `World` will implicitly write to the component's storage in `Resources`.
    let my_entity = world.create_entity().with(MyComponent).build();
    
    // Get a ReadStorage&lt;MyComponent&gt;
    let storage = world.read_storage::&lt;MyComponent&gt;();
    
    // Get the actual component from the storage.
    let my = storage.get(my_entity).expect(&quot;Failed to get component for entity&quot;);
# }
</code></pre>
<a class="header" href="#modifying-a-component" id="modifying-a-component"><h2>Modifying a <code>Component</code></h2></a>
<p>This is almost the same as accessing a component:</p>
<pre><code class="language-rust no_run noplaypen"># extern crate amethyst;
# use amethyst::prelude::Builder;
# struct MyComponent;
# impl amethyst::ecs::Component for MyComponent {
#   type Storage = amethyst::ecs::VecStorage&lt;MyComponent&gt;;
# }
# fn main() {
#   let mut world = amethyst::ecs::World::new();
    let my_entity = world.create_entity().with(MyComponent).build();
    let mut storage = world.write_storage::&lt;MyComponent&gt;();
    let mut my = storage.get_mut(my_entity).expect(&quot;Failed to get component for entity&quot;);
# }
</code></pre>
<a class="header" href="#getting-all-entities" id="getting-all-entities"><h2>Getting all entities</h2></a>
<p>It is pretty rare to use this, but can be useful in some occasions.</p>
<pre><code class="language-rust no_run noplaypen"># extern crate amethyst;
# fn main() {
#   let mut world = amethyst::ecs::World::new();
    // Returns `EntitiesRes`
    let entities = world.entities();
# }
</code></pre>
<a class="header" href="#delete-an-entity" id="delete-an-entity"><h2>Delete an entity</h2></a>
<p>Single:</p>
<pre><code class="language-rust no_run noplaypen"># extern crate amethyst;
# use amethyst::prelude::Builder;
# fn main() {
#   let mut world = amethyst::ecs::World::new();
#   let my_entity = world.create_entity().build();
    world.delete_entity(my_entity).expect(&quot;Failed to delete entity. Was it already removed?&quot;);
# }
</code></pre>
<p>Multiple:</p>
<pre><code class="language-rust no_run noplaypen"># extern crate amethyst;
# use amethyst::prelude::Builder;
# fn main() {
#   let mut world = amethyst::ecs::World::new();
#   let entity_vec: Vec&lt;amethyst::ecs::Entity&gt; = vec![world.create_entity().build()];
    world.delete_entities(entity_vec.as_slice()).expect(&quot;Failed to delete entities from specified list.&quot;);
# }
</code></pre>
<p>All:</p>
<pre><code class="language-rust no_run noplaypen"># extern crate amethyst;
# fn main() {
#   let mut world = amethyst::ecs::World::new();
    world.delete_all();
# }
</code></pre>
<p><strong>Note: Entities are lazily deleted, which means that deletion only happens at the end of the frame and not immediately when calling the <code>delete</code> method.</strong></p>
<a class="header" href="#check-if-the-entity-was-deleted" id="check-if-the-entity-was-deleted"><h2>Check if the entity was deleted</h2></a>
<pre><code class="language-rust no_run noplaypen"># extern crate amethyst;
# use amethyst::prelude::Builder;
# fn main() {
#   let mut world = amethyst::ecs::World::new();
#   let my_entity = world.create_entity().build();
    // Returns true if the entity was **not** deleted.
    let is_alive = world.is_alive(my_entity);
# }
</code></pre>
<a class="header" href="#exec" id="exec"><h2>Exec</h2></a>
<p><strong>This is just to show that this feature exists. It is normal to not understand what it does until you read the system chapter</strong></p>
<p>Sometimes, you will want to create an entity where you need to fetch resources to create the correct components for it.
There is a function that acts as a shorthand for this:</p>
<pre><code class="language-rust no_run noplaypen"># extern crate amethyst;
# use amethyst::ecs::ReadExpect;
# struct Dummy;
# type SomeSystemData&lt;'a&gt; = ReadExpect&lt;'a, Dummy&gt;;
# trait DoSomething {
#   fn do_something(&amp;mut self);
# }
# impl&lt;'a&gt; DoSomething for SomeSystemData&lt;'a&gt; {
#   fn do_something(&amp;mut self) { }
# }
# fn main() {
#   let mut world = amethyst::ecs::World::new();
    world.exec(|mut data: SomeSystemData| {
        data.do_something();
    });
# }
</code></pre>
<p>We will talk about what <code>SystemData</code> is in the system chapter.</p>
<a class="header" href="#system" id="system"><h1>System</h1></a>
<a class="header" href="#what-is-a-system" id="what-is-a-system"><h2>What is a <code>System</code>?</h2></a>
<p>A system is where the logic of the game is executed. In practice, it consists of a struct implementing a function executed on every iteration of the game loop, and taking as an argument data about the game.</p>
<p>Systems can be seen as a small unit of logic. All systems are run by the engine together (even in parallel when possible), and do a specialized operation on one or a group of entities.</p>
<a class="header" href="#structure" id="structure"><h2>Structure</h2></a>
<p>A system struct is a structure implementing the trait <code>amethyst::ecs::System</code>.</p>
<p>Here is a very simple example implementation:</p>
<pre><code class="language-rust no_run noplaypen"># extern crate amethyst;
# use amethyst::ecs::System;
struct MyFirstSystem;

impl&lt;'a&gt; System&lt;'a&gt; for MyFirstSystem {
    type SystemData = ();

    fn run(&amp;mut self, data: Self::SystemData) {
        println!(&quot;Hello!&quot;);
    }
}
</code></pre>
<p>This system will, on every iteration of the game loop, print &quot;Hello!&quot; in the console. This is a pretty boring system as it does not interact at all with the game. Let us spice it up a bit.</p>
<a class="header" href="#accessing-the-context-of-the-game" id="accessing-the-context-of-the-game"><h2>Accessing the context of the game</h2></a>
<p>In the definition of a system, the trait requires you to define a type <code>SystemData</code>. This type defines what data the system will be provided with on each call of its <code>run</code> method. <code>SystemData</code> is only meant to carry information accessible to multiple systems. Data local to a system is usually stored in the system's struct itself instead.</p>
<p>The Amethyst engine provides useful system data types to use in order to access the context of a game. Here are some of the most important ones:</p>
<ul>
<li><strong>Read&lt;'a, Resource&gt;</strong> (respectively <strong>Write&lt;'a, Resource&gt;</strong>) allows you to obtain an immutable (respectively mutable) reference to a resource of the type you specify. This is guaranteed to not fail as if the resource is not available, it will give you the <code>Default::default()</code> of your resource.</li>
<li><strong>ReadExpect&lt;'a, Resource&gt;</strong> (respectively <strong>WriteExpect&lt;'a, Resource&gt;</strong>) is a failable alternative to the previous system data, so that you can use resources that do not implement the <code>Default</code> trait.</li>
<li><strong>ReadStorage&lt;'a, Component&gt;</strong> (respectively <strong>WriteStorage&lt;'a, Component&gt;</strong>) allows you to obtain an immutable (respectively mutable) reference to the entire storage of a certain <code>Component</code> type.</li>
<li><strong>Entities&lt;'a&gt;</strong> allows you to create or destroy entities in the context of a system.</li>
</ul>
<p>You can then use one, or multiple of them via a tuple.</p>
<pre><code class="language-rust no_run noplaypen"># extern crate amethyst;
# use amethyst::ecs::{System, Read};
# use amethyst::core::timing::Time;
struct MyFirstSystem;

impl&lt;'a&gt; System&lt;'a&gt; for MyFirstSystem {
    type SystemData = Read&lt;'a, Time&gt;;

    fn run(&amp;mut self, data: Self::SystemData) {
        println!(&quot;{}&quot;, data.delta_seconds());
    }
}
</code></pre>
<p>Here, we get the <code>amethyst::core::timing::Time</code> resource to print in the console the time elapsed between two frames. Nice! But that's still a bit boring.</p>
<a class="header" href="#manipulating-storages" id="manipulating-storages"><h2>Manipulating storages</h2></a>
<p>Once you have access to a storage, you can use them in different ways.</p>
<a class="header" href="#getting-a-component-of-a-specific-entity" id="getting-a-component-of-a-specific-entity"><h3>Getting a component of a specific entity</h3></a>
<p>Sometimes, it can be useful to get a component in the storage for a specific entity. This can easily be done using the <code>get</code> or, for mutable storages, <code>get_mut</code> methods.</p>
<pre><code class="language-rust no_run noplaypen"># extern crate amethyst;
# use amethyst::ecs::{Entity, System, WriteStorage};
# use amethyst::core::Transform;
struct WalkPlayerUp {
    player: Entity,
}

impl&lt;'a&gt; System&lt;'a&gt; for WalkPlayerUp {
    type SystemData = WriteStorage&lt;'a, Transform&gt;;

    fn run(&amp;mut self, mut transforms: Self::SystemData) {
        transforms.get_mut(self.player).unwrap().translation.y += 0.1;
    }
}
</code></pre>
<p>This system makes the player go up by 0.1 unit every iteration of the game loop! To identify what entity the player is, we stored it beforehand in the system's struct. Then, we get its <code>Transform</code> from the transform storage, and move it along the Y axis by 0.1.</p>
<blockquote>
<p>A transform is a very common structure in game development. It represents the position, rotation and scale of an object in the game world. You will use them a lot, as they are what you need to change when you want to move something around in your game.</p>
</blockquote>
<p>However, this approach is pretty rare because most of the time you don't know what entity you want to manipulate, and in fact you may want to apply your changes to multiple entities.</p>
<a class="header" href="#getting-all-entities-with-specific-components" id="getting-all-entities-with-specific-components"><h3>Getting all entities with specific components</h3></a>
<p>Most of the time, you will want to perform logic on all entities with a specific components, or even all entities with a selection of components.</p>
<p>This is possible using the <code>join</code> method. You may be familiar with joining operations if you have ever worked with databases. The <code>join</code> method takes multiple storages, and iterates over all entities that have a component in each of those storages.
It works like an &quot;AND&quot; gate. It will return an iterator containing a tuple of all the requested components if they are <strong>ALL</strong> on the same entity.</p>
<p>If you join with components A, B and C, only the entities that have <strong>ALL</strong> those components will be considered.</p>
<p>Needless to say that you can use it with only one storage to iterate over all entities with a specific component.</p>
<p>Keep in mind that <strong>the <code>join</code> method is only available by importing <code>amethyst::ecs::Join</code></strong>.</p>
<pre><code class="language-rust no_run noplaypen"># extern crate amethyst;
# use amethyst::ecs::{System, ReadStorage, WriteStorage};
# use amethyst::core::Transform;
# struct FallingObject;
# impl amethyst::ecs::Component for FallingObject {
#   type Storage = amethyst::ecs::DenseVecStorage&lt;FallingObject&gt;;
# }
use amethyst::ecs::Join;

struct MakeObjectsFall;

impl&lt;'a&gt; System&lt;'a&gt; for MakeObjectsFall {
    type SystemData = (
        WriteStorage&lt;'a, Transform&gt;,
        ReadStorage&lt;'a, FallingObject&gt;,
    );

    fn run(&amp;mut self, (mut transforms, falling): Self::SystemData) {
        for (mut transform, _) in (&amp;mut transforms, &amp;falling).join() {
            if transform.translation.y &gt; 0.0 {
                transform.translation.y -= 0.1;
            }
        }
    }
}
</code></pre>
<p>This system will make all entities with both a <code>Transform</code> with a positive y coordinate and a <code>FallingObject</code> tag component fall by 0.1 unit per game loop iteration. Note that as the <code>FallingObject</code> is only here as a tag to restrict the joining operation, we immediately discard it using the <code>_</code> syntax.</p>
<p>Cool! Now that looks like something we'll actually do in our games!</p>
<a class="header" href="#getting-entities-that-have-some-components-but-not-others" id="getting-entities-that-have-some-components-but-not-others"><h3>Getting entities that have some components, but not others</h3></a>
<p>There is a special type of <code>Storage</code> in specs called <code>AntiStorage</code>.
The not operator (!) turns a Storage into its AntiStorage counterpart, allowing you to iterate over entities that do NOT have this <code>Component</code>.
It is used like this:</p>
<pre><code class="language-rust no_run noplaypen"># extern crate amethyst;
# use amethyst::ecs::{System, ReadStorage, WriteStorage};
# use amethyst::core::Transform;
# struct FallingObject;
# impl amethyst::ecs::Component for FallingObject {
#   type Storage = amethyst::ecs::DenseVecStorage&lt;FallingObject&gt;;
# }
use amethyst::ecs::Join;

struct NotFallingObjects;

impl&lt;'a&gt; System&lt;'a&gt; for NotFallingObjects {
    type SystemData = (
        WriteStorage&lt;'a, Transform&gt;,
        ReadStorage&lt;'a, FallingObject&gt;,
    );

    fn run(&amp;mut self, (mut transforms, falling): Self::SystemData) {
        for (mut transform, _) in (&amp;mut transforms, !&amp;falling).join() {
            // If they don't fall, why not make them go up!
            transform.translation.y += 0.1;
        }
    }
}
</code></pre>
<a class="header" href="#manipulating-the-structure-of-entities" id="manipulating-the-structure-of-entities"><h2>Manipulating the structure of entities</h2></a>
<p>It may sometimes be interesting to manipulate the structure of entities in a system, such as creating new ones or modifying the component layout of existing ones. This kind of process is done using the <code>Entities&lt;'a&gt;</code> system data.</p>
<blockquote>
<p>Requesting <code>Entities&lt;'a&gt;</code> does not impact performance, as it contains only immutable resources and therefore <a href="./dispatcher.html">does not block the dispatching</a>.</p>
</blockquote>
<a class="header" href="#creating-new-entities-in-a-system" id="creating-new-entities-in-a-system"><h3>Creating new entities in a system</h3></a>
<p>Creating an entity while in the context of a system is very similar to the way one would create an entity using the <code>World</code> struct. The only difference is that one needs to provide mutable storages of all the components they plan to add to the entity.</p>
<pre><code class="language-rust no_run noplaypen"># extern crate amethyst;
# use amethyst::ecs::{System, WriteStorage, Entities};
# use amethyst::core::Transform;
# struct Enemy;
# impl amethyst::ecs::Component for Enemy {
#   type Storage = amethyst::ecs::VecStorage&lt;Enemy&gt;;
# }
struct SpawnEnemies {
    counter: u32,
}

impl&lt;'a&gt; System&lt;'a&gt; for SpawnEnemies {
    type SystemData = (
        WriteStorage&lt;'a, Transform&gt;,
        WriteStorage&lt;'a, Enemy&gt;,
        Entities&lt;'a&gt;,
    );

    fn run(&amp;mut self, (mut transforms, mut enemies, entities): Self::SystemData) {
        self.counter += 1;
        if self.counter &gt; 200 {
            entities.build_entity()
                .with(Transform::default(), &amp;mut transforms)
                .with(Enemy, &amp;mut enemies)
                .build();
            self.counter = 0;
        }
    }
}
</code></pre>
<p>This system will spawn a new enemy every 200 game loop iterations.</p>
<a class="header" href="#removing-an-entity" id="removing-an-entity"><h3>Removing an entity</h3></a>
<p>Deleting an entity is very easy using <code>Entities&lt;'a&gt;</code>.</p>
<pre><code class="language-rust no_run noplaypen"># extern crate amethyst;
# use amethyst::ecs::{System, Entities, Entity};
# struct MySystem { entity: Entity }
# impl&lt;'a&gt; System&lt;'a&gt; for MySystem {
#   type SystemData = Entities&lt;'a&gt;;
#   fn run(&amp;mut self, entities: Self::SystemData) {
#       let entity = self.entity;
entities.delete(entity);
#   }
# }
</code></pre>
<a class="header" href="#iterating-over-components-with-associated-entity" id="iterating-over-components-with-associated-entity"><h3>Iterating over components with associated entity</h3></a>
<p>Sometimes, when you iterate over components, you may want to also know what entity you are working with. To do that, you can use the joining operation with <code>Entities&lt;'a&gt;</code>.</p>
<pre><code class="language-rust no_run noplaypen"># extern crate amethyst;
# use amethyst::ecs::{Join, System, Entities, WriteStorage, ReadStorage};
# use amethyst::core::Transform;
# struct FallingObject;
# impl amethyst::ecs::Component for FallingObject {
#   type Storage = amethyst::ecs::VecStorage&lt;FallingObject&gt;;
# }
struct MakeObjectsFall;

impl&lt;'a&gt; System&lt;'a&gt; for MakeObjectsFall {
    type SystemData = (
        Entities&lt;'a&gt;,
        WriteStorage&lt;'a, Transform&gt;,
        ReadStorage&lt;'a, FallingObject&gt;,
    );

    fn run(&amp;mut self, (entities, mut transforms, falling): Self::SystemData) {
        for (e, mut transform, _) in (&amp;*entities, &amp;mut transforms, &amp;falling).join() {
            if transform.translation.y &gt; 0.0 {
                transform.translation.y -= 0.1;
            } else {
                entities.delete(e);
            }
        }
    }
}
</code></pre>
<p>This system does the same thing as the previous <code>MakeObjectsFall</code>, but also cleans up falling objects that reached the ground.</p>
<a class="header" href="#adding-or-removing-components" id="adding-or-removing-components"><h3>Adding or removing components</h3></a>
<p>You can also insert or remove components from a specific entity.
To do that, you need to get a mutable storage of the component you want to modify, and simply do:</p>
<pre><code class="language-rust no_run noplaypen"># extern crate amethyst;
# use amethyst::ecs::{System, Entities, Entity, WriteStorage};
# struct MyComponent;
# impl amethyst::ecs::Component for MyComponent {
#   type Storage = amethyst::ecs::VecStorage&lt;MyComponent&gt;;
# }
# struct MySystem { entity: Entity }
# impl&lt;'a&gt; System&lt;'a&gt; for MySystem {
#   type SystemData = WriteStorage&lt;'a, MyComponent&gt;;
#   fn run(&amp;mut self, mut write_storage: Self::SystemData) {
#       let entity = self.entity;
// Add the component
write_storage.insert(entity, MyComponent);

// Remove the component
write_storage.remove(entity);
#   }
# }
</code></pre>
<p>Keep in mind that inserting a component on an entity that already has a component of the same type <strong>will overwrite the previous one</strong>.</p>
<a class="header" href="#the-systemdata-trait" id="the-systemdata-trait"><h2>The SystemData trait</h2></a>
<p>While this is rarely useful, it is possible to create custom <code>SystemData</code> types.</p>
<p>The <code>Dispatcher</code> populates the <code>SystemData</code> on every call of the <code>run</code> method. To do that, your <code>SystemData</code> type must implement the trait <code>amethyst::ecs::SystemData</code> in order to have it be valid.</p>
<p>This is rather complicated trait to implement, fortunately Amethyst provides a derive macro for it, that can implement the trait to any struct as long as all its fields are <code>SystemData</code>. Most of the time however, you will not even need to implement it at all as you will be using <code>SystemData</code> structs provided by the engine.</p>
<p>Please note that tuples of structs implementing <code>SystemData</code> are themselves <code>SystemData</code>. This is very useful when you need to request multiple <code>SystemData</code> at once quickly.</p>
<pre><code class="language-rust no_run noplaypen"># extern crate amethyst;
# extern crate shred;
# #[macro_use] extern crate shred_derive;
# 
# use amethyst::ecs::{ReadStorage, WriteStorage, SystemData, Component, VecStorage, System, Join};
#
# struct FooComponent {
#   stuff: f32,
# }
# impl Component for FooComponent {
#   type Storage = VecStorage&lt;FooComponent&gt;;
# }
# 
# struct BarComponent {
#   stuff: f32,
# }
# impl Component for BarComponent {
#   type Storage = VecStorage&lt;BarComponent&gt;;
# }
# 
# #[derive(SystemData)]
# struct BazSystemData&lt;'a&gt; {
#  field: ReadStorage&lt;'a, FooComponent&gt;,
# }
# 
# impl&lt;'a&gt; BazSystemData&lt;'a&gt; {
#   fn should_process(&amp;self) -&gt; bool {
#       true
#   }
# }
#
#[derive(SystemData)]
struct MySystemData&lt;'a&gt; {
    foo: ReadStorage&lt;'a, FooComponent&gt;,
    bar: WriteStorage&lt;'a, BarComponent&gt;,
    baz: BazSystemData&lt;'a&gt;,
}

struct MyFirstSystem;

impl&lt;'a&gt; System&lt;'a&gt; for MyFirstSystem {
    type SystemData = MySystemData&lt;'a&gt;;

    fn run(&amp;mut self, mut data: Self::SystemData) {
        if data.baz.should_process() {
            for (foo, mut bar) in (&amp;data.foo, &amp;mut data.bar).join() {
                bar.stuff += foo.stuff;
            } 
        }
    }
}
</code></pre>
<a class="header" href="#the-setup-method" id="the-setup-method"><h2>The setup method</h2></a>
<p>Systems have a method called setup which is called a single time, before any of the system runs.
Here is how to use it:</p>
<pre><code class="language-rust no_run noplaypen"># extern crate amethyst;
# use amethyst::ecs::{System, Resources, SystemData, Entity};
# struct MySystem { entity: Entity }
# impl&lt;'a&gt; System&lt;'a&gt; for MySystem {
#   type SystemData = ();
#   fn run(&amp;mut self, _: Self::SystemData) { }
    fn setup(&amp;mut self, res: &amp;mut Resources) {
        // Ensures that resources that implement `Default` and are present in your `SystemData` are added to `Resources`.
        Self::SystemData::setup(res);
        // Do what you want with `Resources` past this point.
    }
# }
</code></pre>
<a class="header" href="#dispatcher" id="dispatcher"><h1>Dispatcher</h1></a>
<a class="header" href="#what-is-a-dispatcher" id="what-is-a-dispatcher"><h2>What is a <code>Dispatcher</code>?</h2></a>
<p>Dispatchers are the heart of the ECS infrastructure. They are the executors that decide when the <code>System</code>s will be executed so that they don't walk over each other.</p>
<p>When a dispatcher is created, it is associated with the systems that it will execute. It then generates an execution plan that respects mutability rules while maximizing parallelism.</p>
<a class="header" href="#respecting-mutability-rules" id="respecting-mutability-rules"><h2>Respecting mutability rules</h2></a>
<p>When a system wants to access a <code>Storage</code> or a resource, they can do so either mutably or immutably. This works just like in Rust: either only one system can request something mutably and no other system can access it, or multiple systems can request something but only immutably.</p>
<p>The dispatcher looks at all the <code>SystemData</code> in the systems and builds execution stages.</p>
<p>If you want to have the best performance possible, you should prefer immutable over mutable whenever it is possible. (<code>Read</code> instead of <code>Write</code>, <code>ReadStorage</code> instead of <code>WriteStorage</code>).</p>
<p><strong>Note: Please however keep in mind that <code>Write</code> is still preferable to locks in most cases, such as <code>Mutex</code> or <code>RwLock</code> for example.</strong></p>
<a class="header" href="#event-channel" id="event-channel"><h1>Event Channel</h1></a>
<p>This chapter will be easier than the previous ones.</p>
<p>While it is not essential to understand it to use amethyst, it can make your life much much easier in a lot of situations where using only data would make your code too complex.</p>
<a class="header" href="#what-is-an-event-channel" id="what-is-an-event-channel"><h2>What is an event channel?</h2></a>
<p>An <code>EventChannel</code> acts like a queue for any type that is <code>Send + Sync + 'static</code>.</p>
<p>It is a single producer/multiple receiver queue. This means that it works best when used with only a single &quot;thing&quot; (usually a system) producing events.
In most cases, the <code>EventChannel</code> should be stored in a global resource for ease of access. More on this later.</p>
<a class="header" href="#creating-an-event-channel" id="creating-an-event-channel"><h2>Creating an event channel</h2></a>
<p>Super simple!</p>
<pre><code class="language-rust no_run noplaypen"># extern crate amethyst;
# use amethyst::shrev::EventChannel;
    // In the following examples, we are going to use `MyEvent` values as events.
    #[derive(Debug)]
    pub enum MyEvent {
        A,
        B,
    }
    
    let mut channel = EventChannel::&lt;MyEvent&gt;::new();
</code></pre>
<a class="header" href="#writing-events-to-the-event-channel" id="writing-events-to-the-event-channel"><h2>Writing events to the event channel</h2></a>
<p>Single:</p>
<pre><code class="language-rust no_run noplaypen"># extern crate amethyst;
# #[derive(Debug)]
# pub enum MyEvent {
#   A,
#   B,
# }
# fn main() {
#   let mut channel = amethyst::shrev::EventChannel::&lt;MyEvent&gt;::new();
    channel.single_write(MyEvent::A);
# }
</code></pre>
<p>Multiple:</p>
<pre><code class="language-rust no_run noplaypen"># extern crate amethyst;
# #[derive(Debug)]
# pub enum MyEvent {
#   A,
#   B,
# }
# fn main() {
#   let mut channel = amethyst::shrev::EventChannel::&lt;MyEvent&gt;::new();
    channel.iter_write(vec![MyEvent::A, MyEvent::A, MyEvent::B].into_iter());
# }
</code></pre>
<a class="header" href="#reading-events" id="reading-events"><h2>Reading events</h2></a>
<p>This is the part where it becomes tricky.
To be able to track where each of the receiver's reading is at, the <code>EventChannel</code> needs to be aware of their presence.
This is done by registering a <code>ReaderId</code>.</p>
<pre><code class="language-rust no_run noplaypen"># extern crate amethyst;
# #[derive(Debug)]
# pub enum MyEvent {
#   A,
#   B,
# }
# fn main() {
#   let mut channel = amethyst::shrev::EventChannel::&lt;MyEvent&gt;::new();
    let mut reader = channel.register_reader();
# }
</code></pre>
<p>Then, when you want to read the events:</p>
<pre><code class="language-rust no_run noplaypen"># extern crate amethyst;
# #[derive(Debug)]
# pub enum MyEvent {
#   A,
#   B,
# }
# fn main() {
#   let mut channel = amethyst::shrev::EventChannel::&lt;MyEvent&gt;::new();
#   let mut reader = channel.register_reader();
    for event in channel.read(&amp;mut reader) {
        // The type of the event is inferred from the generic type
        // we assigned to the `EventChannel&lt;MyEvent&gt;` earlier when creating it.
        println!(&quot;Received event value of: {:?}&quot;, event);
    }
# }
</code></pre>
<p>Note that you only need to have a read access to the channel when reading events.
It is the <code>ReaderId</code> that needs to be mutable to keep track of where your last read was.</p>
<p><strong>IMPORTANT: The event channel automatically grows as events are added to it and only decreases in size once all readers have read through the older events.
This mean that if you create a <code>ReaderId</code> but don't read from it on each frame, the event channel will start to consume more and more memory.</strong></p>
<a class="header" href="#patterns" id="patterns"><h2>Patterns</h2></a>
<p>When using the event channel, we usually re-use the same pattern over and over again to maximize parallelism.
It goes as follow:</p>
<p>Create the event channel and add it to to the world during <code>State</code> creation:</p>
<pre><code class="language-rust no_run noplaypen"># extern crate amethyst;
# use amethyst::shrev::EventChannel;
# #[derive(Debug)]
# pub enum MyEvent {
#   A,
#   B,
# }
# fn main() {
#   let mut world = amethyst::ecs::World::new();
world.add_resource(
    EventChannel::&lt;MyEvent&gt;::new(),
);
# }
</code></pre>
<p><em>Note: You can also derive <code>Default</code>, this way you don't have to manually create your resource and add it. Resources implementing <code>Default</code> are automatically added to <code>Resources</code> when a <code>System</code> uses them (<code>Read</code> or <code>Write</code> in <code>SystemData</code>).</em></p>
<p>In the <strong>producer</strong> <code>System</code>, get a mutable reference to your resource:</p>
<pre><code class="language-rust no_run noplaypen"># extern crate amethyst;
# use amethyst::ecs::Write;
# use amethyst::shrev::EventChannel;
# #[derive(Debug)]
# pub enum MyEvent {
#   A,
#   B,
# }
# struct MySystem;
# impl&lt;'a&gt; amethyst::ecs::System&lt;'a&gt; for MySystem {
type SystemData = Write&lt;'a, EventChannel&lt;MyEvent&gt;&gt;;
#   fn run(&amp;mut self, _: Self::SystemData) { }
# }
</code></pre>
<p>In the <strong>receiver</strong> <code>System</code>s, you need to store the <code>ReaderId</code> somewhere.</p>
<pre><code class="language-rust no_run noplaypen"># extern crate amethyst;
# use amethyst::shrev::ReaderId;
# #[derive(Debug)]
# pub enum MyEvent {
#   A,
#   B,
# }
struct ReceiverSystem {
    // The type inside of ReaderId should be the type of the event you are using.
    reader: Option&lt;ReaderId&lt;MyEvent&gt;&gt;,
}
</code></pre>
<p>and you also need to get read access:</p>
<pre><code class="language-rust no_run noplaypen"># extern crate amethyst;
# use amethyst::ecs::Read;
# use amethyst::shrev::EventChannel;
# #[derive(Debug)]
# pub enum MyEvent {
#   A,
#   B,
# }
# struct MySystem;
# impl&lt;'a&gt; amethyst::ecs::System&lt;'a&gt; for MySystem {
    type SystemData = Read&lt;'a, EventChannel&lt;MyEvent&gt;&gt;;
#   fn run(&amp;mut self, _: Self::SystemData) { }
# }
</code></pre>
<p>Then, in the <code>System</code>'s setup method:</p>
<pre><code class="language-rust no_run noplaypen"># extern crate amethyst;
# use amethyst::shrev::{EventChannel, ReaderId};
# use amethyst::ecs::SystemData;
# #[derive(Debug)]
# pub enum MyEvent {
#   A,
#   B,
# }
# struct MySystem { reader: Option&lt;ReaderId&lt;MyEvent&gt;&gt;, }
# impl&lt;'a&gt; amethyst::ecs::System&lt;'a&gt; for MySystem {
#   type SystemData = ();
#   fn run(&amp;mut self, _: Self::SystemData) { }
#   fn setup(&amp;mut self, res: &amp;mut amethyst::ecs::Resources) {
    // IMPORTANT: You need to setup your system data BEFORE you try to fetch the resource. Especially if you plan use `Default` to create your resource.
    Self::SystemData::setup(res);
    self.reader = Some(res.fetch_mut::&lt;EventChannel&lt;MyEvent&gt;&gt;().register_reader());
#   }
# }

</code></pre>
<p>Finally, you can read events from your <code>System</code>.</p>
<pre><code class="language-rust no_run noplaypen"># extern crate amethyst;
# use amethyst::ecs::Read;
# use amethyst::shrev::EventChannel;
# #[derive(Debug)]
# pub enum MyEvent {
#   A,
#   B,
# }
# struct MySystem {
#   reader: Option&lt;amethyst::shrev::ReaderId&lt;MyEvent&gt;&gt;,
# }
# impl&lt;'a&gt; amethyst::ecs::System&lt;'a&gt; for MySystem {
#   type SystemData = Read&lt;'a, EventChannel&lt;MyEvent&gt;&gt;;
    fn run (&amp;mut self, my_event_channel: Self::SystemData) {
        for event in my_event_channel.read(self.reader.as_mut().unwrap()) {
            println!(&quot;Received an event: {:?}&quot;, event);
        }
    }
# }
</code></pre>
<a class="header" href="#pong-tutorial" id="pong-tutorial"><h1>Pong Tutorial</h1></a>
<p>To get a better feeling for how Amethyst works, we're going to implement a
Pong clone. You can find a <a href="https://github.com/amethyst/amethyst/tree/master/examples/pong">full Pong example</a> (our end goal) in Amethyst's
examples folder. This tutorial breaks that project up into discrete steps so
it's easier to understand what everything is doing. If you've cloned the
Amethyst repo, you can run any of the examples like so:</p>
<pre><code class="language-norun">cargo run --example pong_tutorial_01
</code></pre>
<p>The main difference between real game code and the example code is where the
<code>resources</code> and <code>assets</code> folders are located.</p>
<p>For instance, in the pong_tutorial_01 example we have:</p>
<pre><code class="language-rust ignore">let app_root = application_root_dir();

let path = format!(
    &quot;{}/examples/pong_tutorial_01/resources/display_config.ron&quot;,
    app_root
);
</code></pre>
<p>But for your own project you'll probably want something like this:</p>
<pre><code class="language-rust ignore">let path = &quot;./resources/display_config.ron&quot;;
</code></pre>
<a class="header" href="#opening-and-closing-a-window" id="opening-and-closing-a-window"><h1>Opening (and closing!) a window</h1></a>
<p>Let's start a new project:</p>
<p><code>amethyst new pong</code></p>
<p>If you run this project with <code>cargo run</code>, you'll end up with a window titled
&quot;pong&quot; that renders a really delightful shade of green. Press <code>Esc</code> to quit. If
you're having trouble getting the project to run, double check the
<a href="../getting-started.html">Getting Started</a> guide.</p>
<p>We've opened and closed a window, so we're basically done! But let's write this
functionality ourselves so we're sure we know what's going on.</p>
<p><strong>In <code>src</code> there's a <code>main.rs</code> file. Delete everything in that file, then add these imports:</strong></p>
<pre><code class="language-rust no_run noplaypen">extern crate amethyst;

use amethyst::prelude::*;
use amethyst::renderer::{DisplayConfig, DrawSprite, Event, Pipeline,
                         RenderBundle, Stage, VirtualKeyCode};
</code></pre>
<p>We'll be learning more about these as we go through this tutorial. The prelude
includes the basic (and most important) types like <code>Application</code>, <code>World</code>, and
<code>State</code>.</p>
<p>Now we create our core game struct:</p>
<pre><code class="language-rust no_run noplaypen">pub struct Pong;
</code></pre>
<p>We'll be implementing the <a href="https://www.amethyst.rs/doc/master/doc/amethyst/trait.State.html"><code>State</code></a> trait on this struct, which is used by
Amethyst's state machine to start, stop, and update the game. But for now we'll
just implement two methods:</p>
<pre><code class="language-rust no_run noplaypen"># extern crate amethyst;
# use amethyst::input::{is_close_requested, is_key_down};
# use amethyst::prelude::*;
# use amethyst::renderer::{DisplayConfig, DrawFlat, Pipeline,
#                          PosTex, RenderBundle, Stage};
# struct Pong;
impl&lt;'a, 'b&gt; SimpleState&lt;'a, 'b&gt; for Pong {
}
</code></pre>
<p>The <code>SimpleState</code> already implements a bunch of stuff for us, like the <code>update</code>
and <code>handle_event</code> methods that you would have to implement yourself were you
using just a regular <code>State</code>. In particular, the default implementation for
<code>handle_event</code> returns <code>Trans::Quit</code> when a close signal is received
from your operating system, like when you press the close button in your graphical
environment. This allows the application to quit as needed. The default
implementation for <code>update</code> then just returns <code>Trans::None</code>, signifying that
nothing is supposed to happen.</p>
<p>Now that we know we can quit, let's add some code to actually get things
started! We'll start with our <code>main</code> function, and we'll have it return a
<code>Result</code> so that we can use <code>?</code>. This will allow us to automatically exit
if any errors occur during setup.</p>
<pre><code class="language-rust no_run noplaypen"># extern crate amethyst;
# use amethyst::prelude::*;
fn main() -&gt; amethyst::Result&lt;()&gt; {

    // We'll put the rest of the code here.

    Ok(())
}
</code></pre>
<p>Inside <code>main()</code> we first start the amethyst logger with a default <code>LoggerConfig</code>
so we can see errors, warnings and debug messages while the program is running.</p>
<pre><code class="language-rust no_run noplaypen"># extern crate amethyst;
# use amethyst::prelude::*;
# fn main() -&gt; amethyst::Result&lt;()&gt; {
amethyst::start_logger(Default::default());
# Ok(())
# }
</code></pre>
<p>After the logger is started, we define a path for our display_config.ron file
and load it.</p>
<pre><code class="language-rust no_run noplaypen"># extern crate amethyst;
# use amethyst::prelude::*;
# use amethyst::renderer::DisplayConfig;
# fn main() {
let path = &quot;./resources/display_config.ron&quot;;

let config = DisplayConfig::load(&amp;path);
# }
</code></pre>
<p>This .ron file was automatically generated by <code>amethyst new</code>. If you didn't use
<code>amethyst new</code>, now would be a good time to create this config file inside a
folder named resources. If you already have this file, we have some changes to
make, anyway:</p>
<pre><code class="language-rust ignore">(
  title: &quot;Pong!&quot;,
  dimensions: Some((500, 500)),
  max_dimensions: None,
  min_dimensions: None,
  fullscreen: false,
  multisampling: 0,
  visibility: true,
  vsync: true,
)
</code></pre>
<p>This will set the default window dimensions to 500 x 500, and make the title bar
say &quot;Pong!&quot; instead of the sad, lowercase default of &quot;pong&quot;.</p>
<p>Now, back inside our <code>main()</code> function in main.rs, let's copy and paste some
rendering code so we can keep moving. We'll cover rendering in more depth later
in this tutorial.</p>
<pre><code class="language-rust no_run noplaypen"># extern crate amethyst;
# use amethyst::renderer::{Pipeline, DrawFlat, PosTex, Stage, DrawSprite};
# fn main() {
let pipe = Pipeline::build().with_stage(
    Stage::with_backbuffer()
        .clear_target([0.0, 0.0, 0.0, 1.0], 1.0)
        .with_pass(DrawSprite::new()),
);
# }
</code></pre>
<p>The important thing to know right now is that this renders a black background.
If you want a different color you can tweak the RGBA values inside the
<code>.clear_target</code> method. Values range from 0.0 to 1.0, so to get that cool green
color we started with back, for instance, you can try
<code>[0.00196, 0.23726, 0.21765, 1.0]</code>.</p>
<p>Now let's pack everything up and run it:</p>
<pre><code class="language-rust no_run noplaypen"># extern crate amethyst;
# use amethyst::prelude::*;
# use amethyst::renderer::{DisplayConfig, DrawSprite, Pipeline,
#                        RenderBundle, Stage};
# fn main() -&gt; amethyst::Result&lt;()&gt; {
# let path = &quot;./resources/display_config.ron&quot;;
# let config = DisplayConfig::load(&amp;path);
# let pipe = Pipeline::build().with_stage(Stage::with_backbuffer()
#       .clear_target([0.0, 0.0, 0.0, 1.0], 1.0)
#       .with_pass(DrawSprite::new()),
# );
# struct Pong;
# impl&lt;'a, 'b&gt; SimpleState&lt;'a,'b&gt; for Pong { }
let game_data = GameDataBuilder::default()
    .with_bundle(RenderBundle::new(pipe, Some(config)).with_sprite_sheet_processor())?;
let mut game = Application::new(&quot;./&quot;, Pong, game_data)?;
game.run();
# Ok(())
# }
</code></pre>
<p>We've discovered Amethyst's root object: <a href="https://www.amethyst.rs/doc/master/doc/amethyst/struct.Application.html">Application</a>. It binds the OS
event loop, state machines, timers and other core components in a central place.
Here we're creating a new <code>RenderBundle</code>, adding the <code>Pipeline</code> we created,
along with our config, and building. There is also a helper function
<code>with_basic_renderer</code> on <code>GameDataBuilder</code> that you can use to create your
<code>Pipeline</code> and <code>RenderBundle</code>, that performs most of the actions above. In the
full <code>pong</code> example in the <code>Amethyst</code> repository that function is used instead.</p>
<p>Then we call <code>.run()</code> on <code>game</code> which begins the gameloop. The game will
continue to run until our <code>State</code> returns <code>Trans::Quit</code>, or when all states have
been popped off the state machine's stack.</p>
<p>Finally, let's create a <code>texture</code> folder in the root of the project. This
will contain the <a href="../images/pong_tutorial/pong_spritesheet.png">spritesheet texture</a> <code>pong_spritesheet.png</code> we will need
to render the elements of the game. To go with it, we need a file describing
where the sprites are on the sheet. Let's create, right next to it, a file
called <code>pong_spritesheet.ron</code>. It will contain the following sprite sheet
definition:</p>
<pre><code class="language-text ignore">(
    spritesheet_width: 8.0,
    spritesheet_height: 16.0,
    sprites: [
        (
            x: 0.0,
            y: 0.0,
            width: 4.0,
            height: 16.0,
        ),
        (
            x: 4.0,
            y: 0.0,
            width: 4.0,
            height: 4.0,
        ),
    ],
)
</code></pre>
<p>Success! Now we should be able to compile and run this code and get a window.
It should look something like this:</p>
<p><img src="../images/pong_tutorial/pong_01.png" alt="Step one" /></p>
<a class="header" href="#drawing-the-paddles" id="drawing-the-paddles"><h1>Drawing the paddles</h1></a>
<p>Now let's do some drawing! But to draw something, we need something to draw. In
Amethyst, those &quot;somethings&quot; are called Entities, which are described by
Components.</p>
<p>Amethyst uses Specs for its ECS (Entity-component system), which is a parallel
Entity-component system written in Rust. You can learn more about Specs in the
<a href="https://slide-rs.github.io/specs/">The Specs Book</a>. Here's a basic explanation of ECS from there:</p>
<blockquote>
<p>The term ECS is a shorthand for Entity-component system. These are the three
core concepts. Each entity is associated with some components. Those entities
and components are processed by systems. This way, you have your data
(components) completely separated from the behaviour (systems). An entity just
logically groups components; so a Velocity component can be applied to the
Position component of the same entity.</p>
</blockquote>
<p>I recommend at least skimming the rest of The Specs Book to get a good intuition
of how Amethyst works, especially if you're new to ECS.</p>
<a class="header" href="#a-quick-refactor" id="a-quick-refactor"><h2>A quick refactor</h2></a>
<p>Let's create a new file called <code>pong.rs</code> to hold our core game logic. We can
move the <code>Pong</code> struct over here, and the <code>impl State for Pong</code> block as well.
Then, in <code>main.rs</code> declare a module:</p>
<pre><code class="language-rust ignore">mod pong;
</code></pre>
<p>And in main.rs, at the top of the file, add this import:</p>
<pre><code class="language-rust ignore">use pong::Pong;
</code></pre>
<p>Now you can just delete various <code>main.rs</code> use statements until the Rust compiler
stops complaining about unused imports. In the <code>pong.rs</code> file we'll need these use
statements to make it through this chapter:</p>
<pre><code class="language-rust no_run noplaypen"># extern crate amethyst;
use amethyst::assets::{AssetStorage, Loader};
use amethyst::core::cgmath::Vector3;
use amethyst::core::transform::Transform;
use amethyst::ecs::prelude::{Component, DenseVecStorage};
use amethyst::prelude::*;
use amethyst::renderer::{
    Camera, MaterialTextureSet, PngFormat, Projection, SpriteRender, SpriteSheet,
    SpriteSheetFormat, SpriteSheetHandle, Texture, TextureMetadata,
};
</code></pre>
<a class="header" href="#get-around-the-world" id="get-around-the-world"><h2>Get around the World</h2></a>
<p>First, in <code>pong.rs</code>, let's add a new method to our State implementation: <code>on_start</code>.
This method is called, as you probably guessed, when the State starts.
We will leave it empty for now, but it will become useful later down the line.</p>
<pre><code class="language-rust no_run noplaypen"># extern crate amethyst;
# use amethyst::prelude::*;
# struct MyState;
# impl&lt;'a, 'b&gt; SimpleState&lt;'a, 'b&gt; for MyState {
fn on_start(&amp;mut self, data: StateData&lt;GameData&gt;) {

}
# }
</code></pre>
<p>The <code>StateData&lt;GameData&gt;</code> is a structure given to all State methods. The important
part of its content here is its <code>world</code> field.</p>
<p>The <code>World</code> structure gets passed around everywhere. It carries with it all the
elements of the runtime of our game: entities, components and systems.
Remember when we added bundles in our <code>main.rs</code>, they were in fact adding
all the systems they were holding inside the <code>World</code> before we actually
ran the game.</p>
<a class="header" href="#look-at-your-game-through-the-camera" id="look-at-your-game-through-the-camera"><h2>Look at your game through the Camera</h2></a>
<p>The first thing we will need in our game is a Camera. This is the component
that will determine what is rendered on screen. It behaves just like a
real life camera: it records a specific part of the world and can be
moved around at will.</p>
<p>First, let's define some constants. We will make them public for use in other
modules later:</p>
<pre><code class="language-rust no_run noplaypen">pub const ARENA_HEIGHT: f32 = 100.0;
pub const ARENA_WIDTH: f32 = 100.0;
</code></pre>
<p>These constants will determine the size of our arena.
So, as we're making a pong game, we want to create a camera that will cover
the entire arena. Let's do it!</p>
<pre><code class="language-rust no_run noplaypen"># extern crate amethyst;
# const ARENA_HEIGHT: f32 = 100.0;
# const ARENA_WIDTH: f32 = 100.0;
# use amethyst::prelude::*;
# use amethyst::ecs::World;
# use amethyst::renderer::{Camera, Projection};
# use amethyst::core::Transform;
fn initialise_camera(world: &amp;mut World) {
    let mut transform = Transform::default();
    transform.translation.z = 1.0;
    world
        .create_entity()
        .with(Camera::from(Projection::orthographic(
            0.0,
            ARENA_WIDTH,
            ARENA_HEIGHT,
            0.0,
        )))
        .with(transform)
        .build();
}
</code></pre>
<p>We create an entity that will carry our camera, with an orthographic projection
of the size of our arena (as we want it to cover it all). We attach it a
<code>Transform</code> component, representing its position in the world. Notice that
we moved that transform a bit back on the z axis: this is to make sure the camera
can see properly the sprites that will, for the duration of this tutorial, sit
on the XY plane.</p>
<p><img src="../images/pong_tutorial/camera.png" alt="Illustrating the camera move" /></p>
<p>Note that as the origin of our camera is in the bottom left corner, we set
<code>ARENA_HEIGHT</code> as the top and <code>0.0</code> as the bottom.</p>
<blockquote>
<p>Orthographic projections are a type of 3D visualization on 2D screens
that keeps the size ratio of the 2D images displayed intact. They are very
useful in games without actual 3D, like our pong example. Perspective projections
are another way of displaying graphics, more useful in 3D scenes.</p>
</blockquote>
<p>To finish setting up the camera, let's call it in our State's <code>on_start</code> method:</p>
<pre><code class="language-rust no_run noplaypen"># extern crate amethyst;
# use amethyst::prelude::*;
# use amethyst::ecs::World;
# fn initialise_camera(world: &amp;mut World) { }
# struct MyState;
# impl&lt;'a, 'b&gt; SimpleState&lt;'a, 'b&gt; for MyState {
fn on_start(&amp;mut self, data: StateData&lt;GameData&gt;) {
    let world = data.world;

    initialise_camera(world);
}
# }
</code></pre>
<p>If you run the game now, you will see... a blank window. Unfortunately this will
be the case until we get to the end of this part of the tutorial, but it gets
much better from then on, we promise!</p>
<a class="header" href="#our-first-component" id="our-first-component"><h2>Our first Component</h2></a>
<p>In <code>pong.rs</code> let's create our first <code>Component</code>, a definition of a paddle. We
will make <code>Side</code> and <code>Paddle</code> public for use in other modules later.</p>
<pre><code class="language-rust no_run noplaypen">#[derive(PartialEq, Eq)]
pub enum Side {
    Left,
    Right,
}

pub struct Paddle {
    pub side: Side,
    pub width: f32,
    pub height: f32,
}

impl Paddle {
    fn new(side: Side) -&gt; Paddle {
        Paddle {
            side: side,
            width: 1.0,
            height: 1.0,
        }
    }
}
</code></pre>
<p>&quot;But that just looks like a regular struct!&quot; you might say. And you're right,
here's the special sauce:</p>
<pre><code class="language-rust no_run noplaypen"># extern crate amethyst;
# use amethyst::ecs::{Component, DenseVecStorage};
# struct Paddle;
impl Component for Paddle {
    type Storage = DenseVecStorage&lt;Self&gt;;
}
</code></pre>
<p>By implementing <code>Component</code> for our <code>Paddle</code> struct, and defining the way we'd
like that <code>Component</code> data stored, we can now add the <code>Paddle</code> component to
entities in our game. For more on storage types, check out the
<a href="https://slide-rs.github.io/specs/05_storages.html#densevecstorage">Specs documentation</a>.</p>
<a class="header" href="#initialise-some-entities" id="initialise-some-entities"><h2>Initialise some entities</h2></a>
<p>Now that we have a Paddle component, let's define some paddle entities that
include that component and add them to our <code>World</code>.</p>
<p>First let's look at our math imports:</p>
<pre><code class="language-rust no_run noplaypen"># extern crate amethyst;
use amethyst::core::cgmath::Vector3;
use amethyst::core::transform::Transform;
</code></pre>
<p>Amethyst uses the <a href="https://docs.rs/cgmath/0.15.0/cgmath/">cgmath crate</a> under the hood and exposes it for our use.
Today we just grabbed the <code>Vector3</code> type, which is a very good math thing to have.</p>
<p><code>Transform</code> is an Amethyst ECS component which carry
position and orientation information. It is relative
to a parent, if one exists.</p>
<p>Let's also define some constants for convenience:</p>
<pre><code class="language-rust no_run noplaypen">const PADDLE_HEIGHT: f32 = 16.0;
const PADDLE_WIDTH: f32 = 4.0;
</code></pre>
<p>Okay, let's make some entities! We'll define an <code>initialise_paddles</code> function
which will create left and right paddle entities and attach a <code>Transform</code>
component to each to position them in our world. As we defined earlier,
our canvas is from <code>0.0</code> to <code>ARENA_WIDTH</code> in the horizontal dimension and
from <code>0.0</code> to <code>ARENA_HEIGHT</code> in the vertical dimension.
Keep in mind that the anchor point of our entities will be in the middle of the
image we will want to render on top of them. This is a good rule to follow in
general as it makes operations like rotation easier.</p>
<pre><code class="language-rust no_run noplaypen"># extern crate amethyst;
# use amethyst::prelude::*;
# use amethyst::core::Transform;
# use amethyst::core::cgmath::Vector3;
# use amethyst::ecs::World;
# enum Side {
#   Left,
#   Right,
# }
# struct Paddle;
# impl amethyst::ecs::Component for Paddle {
#   type Storage = amethyst::ecs::VecStorage&lt;Paddle&gt;;    
# }
# impl Paddle {
#   fn new(side: Side) -&gt; Paddle { Paddle }
# }
# const PADDLE_HEIGHT: f32 = 16.0;
# const PADDLE_WIDTH: f32 = 4.0;
# const ARENA_HEIGHT: f32 = 100.0;
# const ARENA_WIDTH: f32 = 100.0;
/// Initialises one paddle on the left, and one paddle on the right.
fn initialise_paddles(world: &amp;mut World) {
    let mut left_transform = Transform::default();
    let mut right_transform = Transform::default();

    // Correctly position the paddles.
    let y = ARENA_HEIGHT / 2.0;
    left_transform.translation = Vector3::new(PADDLE_WIDTH * 0.5, y, 0.0);
    right_transform.translation = Vector3::new(ARENA_WIDTH - PADDLE_WIDTH * 0.5, y, 0.0);

    // Create a left plank entity.
    world
        .create_entity()
        .with(Paddle::new(Side::Left))
        .with(left_transform)
        .build();

    // Create right plank entity.
    world
        .create_entity()
        .with(Paddle::new(Side::Right))
        .with(right_transform)
        .build();
}
</code></pre>
<p>This is all the information Amethyst needs to track and move the paddles in our
virtual world, but we'll need to do some more work to actually <em>draw</em> them.</p>
<p>As a sanity check, let's make sure the code for initialising the paddles
compiles. Update the <code>on_start</code> method to the following:</p>
<pre><code class="language-rust no_run noplaypen"># extern crate amethyst;
# use amethyst::prelude::*;
# use amethyst::ecs::World;
# fn initialise_paddles(world: &amp;mut World) { }
# fn initialise_camera(world: &amp;mut World) { }
# struct MyState;
# impl&lt;'a, 'b&gt; SimpleState&lt;'a, 'b&gt; for MyState {
fn on_start(&amp;mut self, data: StateData&lt;GameData&gt;) {
    let world = data.world;

    initialise_paddles(world);
    initialise_camera(world);
}
# }
</code></pre>
<p>Let's run our blank screen game!</p>
<pre><code class="language-text ignore">thread 'main' panicked at 'Tried to fetch a resource, but the resource does not exist.
Try adding the resource by inserting it manually or using the `setup` method.
</code></pre>
<p>Uh oh, what's wrong? Sadly the message is pretty difficult to decipher.</p>
<p>If you are using a <code>nightly</code> compiler and enable the <code>nightly</code> feature of
Amethyst, you will receive a more informative error message:</p>
<pre><code class="language-text ignore">thread 'main' panicked at 'Tried to fetch a resource of type &quot;amethyst::specs::storage::MaskedStorage&lt;pong::Paddle&gt;&quot;, but the resource does not exist.
Try adding the resource by inserting it manually or using the `setup` method.'
</code></pre>
<p>For a <code>Component</code> to be used, there must be a <code>Storage&lt;ComponentType&gt;</code> resource
set up in the <code>World</code>. The error message above means we have registered the
<code>Paddle</code> component on an entity, but have not set up the <code>Storage</code>. We can fix
this by adding the following line before <code>initialise_paddles(world)</code> in the
<code>on_start</code> method:</p>
<pre><code class="language-rust no_run noplaypen"># extern crate amethyst;
# struct Paddle;
# impl amethyst::ecs::Component for Paddle {
#   type Storage = amethyst::ecs::VecStorage&lt;Paddle&gt;;    
# }
# fn register() {
#   let mut world = amethyst::ecs::World::new();
world.register::&lt;Paddle&gt;();
# }
</code></pre>
<p>This is rather inconvenient — to need to manually register each component
before it can be used. There <em>must</em> be a better way. <strong>Hint:</strong> there is.</p>
<p>When we add systems to our application, any component that a <code>System</code> uses is
automatically registered. However, as we haven't got any <code>System</code>s we have to
live with registering the <code>Paddle</code> component manually.</p>
<p>Let's run the game again.</p>
<pre><code class="language-text ignore">thread 'main' panicked at 'Tried to fetch a resource, but the resource does not exist.
Try adding the resource by inserting it manually or using the `setup` method.
</code></pre>
<p>Ah, oops. We forgot something. Turning on the <code>nightly</code> feature, we get:</p>
<pre><code class="language-text_ignore">thread 'main' panicked at 'Tried to fetch a resource of type &quot;specs::storage::MaskedStorage&lt;transform::components::local_transform::Transform&gt;&quot;, but the resource does not exist.
Try adding the resource by inserting it manually or using the `setup` method.'
</code></pre>
<p>This is the same kind of error as before; this time the <code>Component</code> is a
<code>Transform</code>, which is used and hence registered by the <code>TransformSystem</code>.</p>
<p>Amethyst has a lot of internal systems it uses to keep things running we need
to bring into the context of the <code>World</code>. For simplicity, these have been
wrapped up into &quot;Bundles&quot; which include related systems and resources. We can
add these to our Application's <code>GameData</code> using the <code>with_bundle</code> method. We
already have one of these in <code>main.rs</code>: the <code>RenderBundle</code>. We can just follow
the pattern and add the <code>TransformBundle</code>.</p>
<pre><code class="language-rust no_run noplaypen"># extern crate amethyst;
# use amethyst::prelude::*;
# use amethyst::core::transform::TransformBundle;
# use amethyst::renderer::{DisplayConfig, DrawSprite, Event, Pipeline,
#                        RenderBundle, Stage, VirtualKeyCode};
# fn main() -&gt; amethyst::Result&lt;()&gt; {
# let path = &quot;./resources/display_config.ron&quot;;
# let config = DisplayConfig::load(&amp;path);
# let pipe = Pipeline::build().with_stage(Stage::with_backbuffer()
#       .clear_target([0.0, 0.0, 0.0, 1.0], 1.0)
#       .with_pass(DrawSprite::new()),
# );
# struct Pong;
# impl&lt;'a, 'b&gt; SimpleState&lt;'a, 'b&gt; for Pong { }
let game_data = GameDataBuilder::default()
    .with_bundle(RenderBundle::new(pipe, Some(config)).with_sprite_sheet_processor())?
    .with_bundle(TransformBundle::new())?;
# Ok(())
# }
</code></pre>
<p>Also we'll need to import it:</p>
<pre><code class="language-rust no_run noplaypen"># extern crate amethyst;
use amethyst::core::transform::TransformBundle;
</code></pre>
<p>This time, when you run the game you should see the familiar black screen.
Hooray!</p>
<a class="header" href="#drawing" id="drawing"><h2>Drawing</h2></a>
<p>This section will finally allow us to see something.</p>
<p>The first thing we will have to do is load the sprite sheet we will use for all
our graphics in the game. Here, it is located in <code>texture/pong_spritesheet.png</code>.
We will perform the loading in a new function called <code>load_sprite_sheet</code>.</p>
<p>First, let's declare the function and load the spritesheet's image.</p>
<pre><code class="language-rust no_run noplaypen"># extern crate amethyst;
# use amethyst::prelude::*;
# use amethyst::assets::{Loader, AssetStorage};
# use amethyst::renderer::{Texture, PngFormat, TextureHandle, TextureMetadata, SpriteSheetHandle};
# use amethyst::ecs::World;
fn load_sprite_sheet(world: &amp;mut World) -&gt; SpriteSheetHandle {
    // Load the sprite sheet necessary to render the graphics.
    // The texture is the pixel data
    // `texture_handle` is a cloneable reference to the texture
    let texture_handle = {
        let loader = world.read_resource::&lt;Loader&gt;();
        let texture_storage = world.read_resource::&lt;AssetStorage&lt;Texture&gt;&gt;();
        loader.load(
            &quot;texture/pong_spritesheet.png&quot;,
            PngFormat,
            TextureMetadata::srgb_scale(),
            (),
            &amp;texture_storage,
        )
    };

    //...
#   unimplemented!()
}
</code></pre>
<p>The <code>Loader</code> is an asset loader which is defined as a <code>resource</code> (not an
<code>Entity</code>, <code>Component</code>, or <code>System</code>, but still a part of our ECS <code>world</code>). It was
created when we built our Application in <code>main.rs</code>, and it can read assets like
.obj files, but also it can <code>load</code> a .png as a <code>Texture</code> as in our use case.</p>
<blockquote>
<p>Resources in Specs are a type of data which can be shared between systems,
while being independent from entities, in contrast to components, which are
attached to specific entities. We'll explore this more later on.</p>
</blockquote>
<p>The <code>AssetStorage&lt;Texture&gt;</code> is also a <code>resource</code>, this is where the loader will
put the <code>Texture</code> it will load from our sprite sheet. In order to manage them
while remaining fast, Amethyst does not give us direct access to the assets we load.
If it did otherwise, we would have to wait for the texture to be fully loaded to do all the
other things we have to prepare, which would be a waste of time!
Instead, the <code>load</code> function will return a <code>Handle&lt;Texture&gt;</code> (also known as <code>TextureHandle</code>).
This handle &quot;points&quot; to the place where the asset will be loaded. In Rust terms, it is
equivalent to a reference-counted option. It is extremely useful, especially as cloning
the handle does not clone the asset in memory, so many things can use the same asset at once.</p>
<p>Heading back to the code, we need to add this snippet after loading the texture.</p>
<pre><code class="language-rust no_run noplaypen"># extern crate amethyst;
# use amethyst::prelude::*;
# use amethyst::assets::{Loader, AssetStorage};
# use amethyst::renderer::{Texture, PngFormat, TextureHandle, MaterialTextureSet, SpriteSheetHandle, TextureMetadata};
# use amethyst::ecs::World;
# fn load_sprite_sheet(world: &amp;mut World) {
#   let texture_handle = {
#       let loader = world.read_resource::&lt;Loader&gt;();
#       let texture_storage = world.read_resource::&lt;AssetStorage&lt;Texture&gt;&gt;();
#       loader.load(
#           &quot;texture/pong_spritesheet.png&quot;,
#           PngFormat,
#           TextureMetadata::srgb_scale(),
#           (),
#           &amp;texture_storage,
#       )
#   };
// `texture_id` is a application defined ID given to the texture to store in
// the `World`. This is needed to link the texture to the sprite_sheet.
let texture_id = 0;
let mut material_texture_set = world.write_resource::&lt;MaterialTextureSet&gt;();
material_texture_set.insert(texture_id, texture_handle);
# }
</code></pre>
<p>The <code>MaterialTextureSet</code> is yet another <code>resource</code>, which is a bi-directional
map between an application defined texture ID and the handle of the loaded
texture. In other words, this allows us to associate a specific global ID to
our texture. As you will see in a moment, <code>SpriteSheet</code>s are linked to textures
through this ID. Since we only have one sprite sheet, we can just use <code>0</code> as the
ID.</p>
<p>Finally, we load the file containing the position of each sprites on the sheet.</p>
<pre><code class="language-rust no_run noplaypen"># extern crate amethyst;
# use amethyst::prelude::*;
# use amethyst::assets::{Loader, AssetStorage};
# use amethyst::renderer::{Texture, PngFormat, TextureHandle, MaterialTextureSet, SpriteSheetHandle, SpriteSheetFormat, SpriteSheet, TextureMetadata};
# use amethyst::ecs::World;
# fn load_sprite_sheet(world: &amp;mut World) -&gt; SpriteSheetHandle {
#   let texture_handle = {
#       let loader = world.read_resource::&lt;Loader&gt;();
#       let texture_storage = world.read_resource::&lt;AssetStorage&lt;Texture&gt;&gt;();
#       loader.load(
#           &quot;texture/pong_spritesheet.png&quot;,
#           PngFormat,
#           TextureMetadata::srgb_scale(),
#           (),
#           &amp;texture_storage,
#       )
#   };
#   let texture_id = 0;
#   let mut material_texture_set = world.write_resource::&lt;MaterialTextureSet&gt;();
#   material_texture_set.insert(texture_id, texture_handle);
let loader = world.read_resource::&lt;Loader&gt;();
let sprite_sheet_store = world.read_resource::&lt;AssetStorage&lt;SpriteSheet&gt;&gt;();
loader.load(
    &quot;texture/pong_spritesheet.ron&quot;, // Here we load the associated ron file
    SpriteSheetFormat,
    texture_id, // We pass it the ID of the texture we want it to use
    (),
    &amp;sprite_sheet_store,
)
# }
</code></pre>
<p>This is where we have to use the associated ID. The <code>Loader</code> will take the
file containing the sprites' positions and the texture ID, and create a
nicely packaged <code>SpriteSheet</code> struct. It is this struct that we will be using
to actually draw stuff on the screen.</p>
<p>Please note that the order of sprites declared in the sprite sheet file
is also significant, as sprites are referenced by the index in
the vector. If you're wondering about the ball sprite, it does exist on the
image, but we will get to it in a later part of the tutorial.</p>
<p>So far, so good. We have a sprite sheet loaded, now we need to link the sprites
to the paddles. We update the <code>initialise_paddle</code> function by changing its
signature to:</p>
<pre><code class="language-rust no_run noplaypen"># extern crate amethyst;
# use amethyst::ecs::World;
# use amethyst::renderer::SpriteSheetHandle;
fn initialise_paddles(world: &amp;mut World, sprite_sheet: SpriteSheetHandle)
# { }
</code></pre>
<p>Inside <code>initialise_paddles</code>, we construct a <code>SpriteRender</code> for each paddle.</p>
<pre><code class="language-rust no_run noplaypen"># extern crate amethyst;
# use amethyst::ecs::World;
# use amethyst::renderer::{SpriteSheetHandle, SpriteRender};
# fn initialise_paddles(world: &amp;mut World, sprite_sheet: SpriteSheetHandle) {
// Assign the sprites for the paddles
let sprite_render_left = SpriteRender {
    sprite_sheet: sprite_sheet.clone(),
    sprite_number: 0, // paddle is the first sprite in the sprite_sheet
    flip_horizontal: false,
    flip_vertical: false,
};

let sprite_render_right = SpriteRender {
    sprite_sheet: sprite_sheet,
    sprite_number: 0,
    flip_horizontal: true,
    flip_vertical: false,
};
# }
</code></pre>
<p><code>SpriteRender</code> is the <code>Component</code> that indicates which sprite of which sprite
sheet should be drawn for a particular entity. Since the paddle is the first
sprite in the sprite sheet, we use <code>0</code> for the <code>sprite_number</code>.</p>
<p>Next we simply add the components to the paddle entities:</p>
<pre><code class="language-rust no_run noplaypen"># extern crate amethyst;
# use amethyst::ecs::World;
# use amethyst::renderer::{SpriteSheetHandle, SpriteRender};
# use amethyst::prelude::*;
# fn initialise_paddles(world: &amp;mut World, sprite_sheet: SpriteSheetHandle) {
# let sprite_render_left = SpriteRender {
#   sprite_sheet: sprite_sheet.clone(),
#   sprite_number: 0, // paddle is the first sprite in the sprite_sheet
#   flip_horizontal: false,
#   flip_vertical: false,
# };
# let sprite_render_right = SpriteRender {
#   sprite_sheet: sprite_sheet,
#   sprite_number: 0,
#   flip_horizontal: true,
#   flip_vertical: false,
# };
// Create a left plank entity.
world
    .create_entity()
    .with(sprite_render_left)
    // ... other components
    .build();

// Create right plank entity.
world
    .create_entity()
    .with(sprite_render_right)
    // ... other components
    .build();
# }
</code></pre>
<p>We're nearly there, we just have to wire up the sprite to the paddles. We put it
all together in the <code>on_start()</code> method:</p>
<pre><code class="language-rust no_run noplaypen"># extern crate amethyst;
# use amethyst::prelude::*;
# use amethyst::renderer::{TextureHandle, SpriteSheetHandle};
# use amethyst::ecs::World;
# struct Paddle;
# impl amethyst::ecs::Component for Paddle {
#   type Storage = amethyst::ecs::VecStorage&lt;Paddle&gt;;    
# }
# fn initialise_paddles(world: &amp;mut World, spritesheet: SpriteSheetHandle) { }
# fn initialise_camera(world: &amp;mut World) { }
# fn load_sprite_sheet(world: &amp;mut World) -&gt; SpriteSheetHandle { unimplemented!() }
# struct MyState;
# impl&lt;'a, 'b&gt; SimpleState&lt;'a, 'b&gt; for MyState {
fn on_start(&amp;mut self, data: StateData&lt;GameData&gt;) {
    let world = data.world;

    // Load the spritesheet necessary to render the graphics.
    let sprite_sheet_handle = load_sprite_sheet(world);

    world.register::&lt;Paddle&gt;();

    initialise_paddles(world, sprite_sheet_handle);
    initialise_camera(world);
}
# }
</code></pre>
<p>And we're done. Let's run our game and have fun!</p>
<p>If all is well, we should get something that looks like this:</p>
<p><img src="../images/pong_tutorial/pong_02.png" alt="Step two" /></p>
<p>In the next chapter we'll explore the &quot;S&quot; in ECS and actually get these paddles
moving!</p>
<a class="header" href="#moving-the-paddles" id="moving-the-paddles"><h1>Moving the paddles</h1></a>
<p>In the previous chapter, we learned about the relationship between entities and
components, and how they represent the &quot;things&quot; in our games. This chapter
introduces Systems - the S in &quot;ECS&quot;. Systems are objects that represent
operations over entities, or more specifically, combinations of components.
Let's add a system that moves the paddles based on user input.</p>
<p>A system is nothing more than a function that runs once each frame and
potentially makes some changes to components. If you've used other game
engines, this probably sounds familiar: Unity engine calls these objects
<code>MonoBehaviour</code>s and Unreal engine calls them <code>Actor</code>s, but these all represent
the same basic idea.</p>
<p>Systems in specs/Amethyst are slightly different. Rather than describe the
behavior of a single instance (eg, a single enemy in your game), they describe
the behavior of all components of a specific type (all enemies). This makes
your code more modular, easier to test, and makes it run faster.</p>
<p>Let's get started.</p>
<a class="header" href="#capturing-user-input" id="capturing-user-input"><h2>Capturing user input</h2></a>
<p>To capture user input, we'll need to introduce a few more files to our game.
Let's start by creating a resource file under the <code>resources</code> directory of our
project, called <code>bindings_config.ron</code>:</p>
<pre><code class="language-ron ignore">(
  axes: {
    &quot;left_paddle&quot;: Emulated(pos: Key(W), neg: Key(S)),
    &quot;right_paddle&quot;: Emulated(pos: Key(Up), neg: Key(Down)),
  },
  actions: {},
)
</code></pre>
<p>In Amethyst, inputs can be either scalar inputs (a button that is either
pressed or not), or axes (a range that represents an analog controller stick or
relates two buttons as opposite ends of a range).
In this file, we're creating two axes: W and S will move the
left paddle up and down, and the Up and Down arrow keys will move the right
paddle up and down.</p>
<p>Next, we'll add an input bundle to the game's <code>Application</code> object, that
contains an input handler system which captures inputs and maps them to the
axes we defined. Let's make the following changes to <code>main.rs</code>.</p>
<pre><code class="language-rust no_run noplaypen"># extern crate amethyst;
# use amethyst::prelude::*;
# use amethyst::core::transform::TransformBundle;
# use amethyst::utils::application_root_dir;
# use amethyst::renderer::{DisplayConfig, DrawFlat, Event, Pipeline,
#                        PosTex, RenderBundle, Stage, VirtualKeyCode};
# macro_rules! env { ($x:expr) =&gt; (&quot;&quot;) }
# fn main() -&gt; amethyst::Result&lt;()&gt; {
use amethyst::input::InputBundle;

let binding_path = format!(
    &quot;{}/resources/bindings_config.ron&quot;,
    application_root_dir()
);

let input_bundle = InputBundle::&lt;String, String&gt;::new().with_bindings_from_file(binding_path)?;

# let path = &quot;./resources/display_config.ron&quot;;
# let config = DisplayConfig::load(&amp;path);
# let pipe = Pipeline::build().with_stage(Stage::with_backbuffer()
#       .clear_target([0.0, 0.0, 0.0, 1.0], 1.0)
#       .with_pass(DrawFlat::&lt;PosTex&gt;::new()),
# );
# struct Pong;
# impl&lt;'a, 'b&gt; SimpleState&lt;'a, 'b&gt; for Pong { }
let game_data = GameDataBuilder::default()
    .with_bundle(RenderBundle::new(pipe, Some(config)).with_sprite_sheet_processor())?
    .with_bundle(TransformBundle::new())?
    .with_bundle(input_bundle)?;
let mut game = Application::new(&quot;./&quot;, Pong, game_data)?;
game.run();
# Ok(())
# }
</code></pre>
<p>At this point, we're ready to write a system that reads input from the
<code>InputHandler</code>, and moves the paddles accordingly. First, we'll create a
directory called <code>systems</code> under <code>src</code> to hold all our systems. We'll use a
module to collect and export each of our systems to the rest of the
application. Here's our <code>mod.rs</code> for <code>src/systems</code>:</p>
<pre><code class="language-rust ignore">mod paddle;

pub use self::paddle::PaddleSystem;
</code></pre>
<p>We're finally ready to implement the <code>PaddleSystem</code> in <code>systems/paddle.rs</code>:</p>
<pre><code class="language-rust no_run noplaypen"># extern crate amethyst;
use amethyst::core::Transform;
use amethyst::ecs::{Join, Read, ReadStorage, System, WriteStorage};
use amethyst::input::InputHandler;
# pub enum Side {
#   Left,
#   Right,
# }
# pub struct Paddle {
#   side: Side,
# }
# impl amethyst::ecs::Component for Paddle {
#   type Storage = amethyst::ecs::VecStorage&lt;Paddle&gt;;    
# }
pub struct PaddleSystem;

impl&lt;'s&gt; System&lt;'s&gt; for PaddleSystem {
  type SystemData = (
    WriteStorage&lt;'s, Transform&gt;,
    ReadStorage&lt;'s, Paddle&gt;,
    Read&lt;'s, InputHandler&lt;String, String&gt;&gt;,
  );

  fn run(&amp;mut self, (mut transforms, paddles, input): Self::SystemData) {
    for (paddle, transform) in (&amp;paddles, &amp;mut transforms).join() {
      let movement = match paddle.side {
        Side::Left =&gt; input.axis_value(&quot;left_paddle&quot;),
        Side::Right =&gt; input.axis_value(&quot;right_paddle&quot;),
      };
      if let Some(mv_amount) = movement {
        if mv_amount != 0.0 {
          let side_name = match paddle.side {
            Side::Left =&gt; &quot;left&quot;,
            Side::Right =&gt; &quot;right&quot;,
          };
          println!(&quot;Side {:?} moving {}&quot;, side_name, mv_amount);
        }
      }
    }
  }
}
</code></pre>
<p>Note: You will also need to add a <code>use</code> statement to bring in <code>Paddle</code> and <code>Side</code> from pong.rs:</p>
<pre><code class="language-rust ignore">use pong::{Paddle, Side, ARENA_HEIGHT, PADDLE_HEIGHT};
</code></pre>
<p>Now lets add this system to our <code>GameDataBuilder</code> in <code>main.rs</code>:</p>
<pre><code class="language-rust no_run noplaypen"># extern crate amethyst;
# use amethyst::prelude::*;
# use amethyst::core::transform::TransformBundle;
# use amethyst::renderer::{DisplayConfig, DrawFlat, Pipeline,
#                        PosTex, RenderBundle, Stage};
# fn main() -&gt; amethyst::Result&lt;()&gt; {
# let path = &quot;./resources/display_config.ron&quot;;
# let config = DisplayConfig::load(&amp;path);
# let pipe = Pipeline::build().with_stage(Stage::with_backbuffer()
#       .clear_target([0.0, 0.0, 0.0, 1.0], 1.0)
#       .with_pass(DrawFlat::&lt;PosTex&gt;::new()),
# );
# mod systems {
# use amethyst;
# pub struct PaddleSystem;
# impl&lt;'a&gt; amethyst::ecs::System&lt;'a&gt; for PaddleSystem {
# type SystemData = ();
# fn run(&amp;mut self, _: Self::SystemData) { }
# }
# }
# let input_bundle = amethyst::input::InputBundle::&lt;String, String&gt;::new();
// in the run() function
let game_data = GameDataBuilder::default()
    .with_bundle(RenderBundle::new(pipe, Some(config)).with_sprite_sheet_processor())?
    .with_bundle(TransformBundle::new())?
    .with_bundle(input_bundle)?
    .with(systems::PaddleSystem, &quot;paddle_system&quot;, &amp;[&quot;input_system&quot;]); // Add this line
# Ok(())
# }
</code></pre>
<p>Don't forget to also add at the top of <code>main.rs</code>:</p>
<pre><code class="language-rust ignore">mod systems;
</code></pre>
<p>Take a look at the <code>with</code> method call. Here, we're not adding a bundle, we're adding
a system alone. We provide an instance of the system, a string representing its name
and a list of dependencies. The dependencies are the names of the systems that
must be ran before our newly added system. Here, we require the <code>input_system</code> to be
ran as we will use the user's input to move the paddles, so we need to have this
data be prepared.</p>
<p>Back in <code>paddle.rs</code>, let's review what our system does, because there's quite a bit there.</p>
<p>We create a unit struct, called <code>PaddleSystem</code>, and implement the <code>System</code>
trait for it. The trait specifies the lifetime of the components on which it
operates. Inside the implementation, we define the <code>SystemData</code> the system
operates on, a tuple of <code>WriteStorage</code>, <code>ReadStorage</code>, and <code>Read</code>. More
specifically, the generic types we've used here tell us that the <code>PaddleSystem</code>
mutates <code>LocalTransform</code> components, <code>WriteStorage&lt;'s, LocalTransform&gt;</code>, it
reads <code>Paddle</code> components, <code>ReadStorage&lt;'s, Paddle&gt;</code>, and also accesses the
<code>InputHandler&lt;String, String&gt;</code> resource we created earlier, using the <code>Read</code>
structure.</p>
<p>Then, now that we have access to the storages of the components we want, we can
iterate over them. We perform a join operation between the <code>Transform</code> and <code>Paddle</code>
storages. This will iterate over all entities that have both a <code>Paddle</code> and <code>Transform</code>
attached to them, and give us access to the actual components, immutably for the
<code>Paddle</code> and mutably for the <code>Transform</code>.</p>
<blockquote>
<p>There are many other ways to use storages. For example, you can use them to get
a reference to the component of a specific type held by an entity, or simply
iterate over them without joining. However in practice, your most common use will
be to join over multiple storages as it is rare to have a system affect
only one specific component.</p>
</blockquote>
<blockquote>
<p>Please also note that it is possible to join over storages using multiple threads
by using <code>par_join</code> instead of <code>join</code>, but here the overhead introduced is not
worth the gain offered by parallelism.</p>
</blockquote>
<a class="header" href="#modifying-the-transform" id="modifying-the-transform"><h2>Modifying the transform</h2></a>
<p>If we run the game now, we'll see the console print our keypresses. Let's
make it update the position of the paddle. To do this, we'll modify the y
component of the transform's translation.</p>
<pre><code class="language-rust no_run noplaypen"># extern crate amethyst;
# use amethyst::core::Transform;
# use amethyst::ecs::{Join, Read, ReadStorage, System, WriteStorage};
# use amethyst::input::InputHandler;
# enum Side {
#   Left,
#   Right,
# }
# pub struct Paddle {
#   side: Side,
# }
# impl amethyst::ecs::Component for Paddle {
#   type Storage = amethyst::ecs::VecStorage&lt;Paddle&gt;;    
# }
# pub struct PaddleSystem;
# impl&lt;'s&gt; System&lt;'s&gt; for PaddleSystem {
#  type SystemData = (
#    WriteStorage&lt;'s, Transform&gt;,
#    ReadStorage&lt;'s, Paddle&gt;,
#    Read&lt;'s, InputHandler&lt;String, String&gt;&gt;,
#  );
  fn run(&amp;mut self, (mut transforms, paddles, input): Self::SystemData) {
    for (paddle, mut transform) in (&amp;paddles, &amp;mut transforms).join() {
      let movement = match paddle.side {
        Side::Left =&gt; input.axis_value(&quot;left_paddle&quot;),
        Side::Right =&gt; input.axis_value(&quot;right_paddle&quot;),
      };
      if let Some(mv_amount) = movement {
        let scaled_amount = 1.2 * mv_amount as f32;
        transform.translation[1] += scaled_amount;
      }
    }
  }
# }
</code></pre>
<p>This is our first attempt at moving the paddles: we take the movement, and
scale it by some factor to make the motion seem smooth. In a real game, we
would use the time elapsed between frames to determine how far to move the
paddle, so that the behavior of the game would not be tied to the game's
framerate, but this will do for now. If you run the game now, you'll notice
the paddles are able to &quot;fall&quot; off the edges of the game area.</p>
<p>To fix this, we'll make sure the paddle's anchor point never gets out of the
arena. But as the anchor point is in the middle of the sprite, we also need
to add a margin for the paddle to not go halfway out of the screen.
Therefore, we will border the y value of the transform from
<code>ARENA_HEIGHT - PADDLE_HEIGHT * 0.5</code> (the top of the screen but a little bit
lower) to <code>PADDLE_HEIGHT * 0.5</code> (the bottom of the screen but a little bit higher).</p>
<p>Our run function should now look something like this:</p>
<pre><code class="language-rust no_run noplaypen"># extern crate amethyst;
# use amethyst::core::Transform;
# use amethyst::ecs::{Join, Read, ReadStorage, System, WriteStorage};
# use amethyst::input::InputHandler;
# const PADDLE_HEIGHT: f32 = 16.0;
# const PADDLE_WIDTH: f32 = 4.0;
# const ARENA_HEIGHT: f32 = 100.0;
# const ARENA_WIDTH: f32 = 100.0;
# enum Side {
#   Left,
#   Right,
# }
# pub struct Paddle {
#   side: Side,
# }
# impl amethyst::ecs::Component for Paddle {
#   type Storage = amethyst::ecs::VecStorage&lt;Paddle&gt;;    
# }
# pub struct PaddleSystem;
# impl&lt;'s&gt; System&lt;'s&gt; for PaddleSystem {
#  type SystemData = (
#    WriteStorage&lt;'s, Transform&gt;,
#    ReadStorage&lt;'s, Paddle&gt;,
#    Read&lt;'s, InputHandler&lt;String, String&gt;&gt;,
#  );
  fn run(&amp;mut self, (mut transforms, paddles, input): Self::SystemData) {
    for (paddle, mut transform) in (&amp;paddles, &amp;mut transforms).join() {
      let movement = match paddle.side {
        Side::Left =&gt; input.axis_value(&quot;left_paddle&quot;),
        Side::Right =&gt; input.axis_value(&quot;right_paddle&quot;),
      };
      if let Some(mv_amount) = movement {
        let scaled_amount = 1.2 * mv_amount as f32;
        transform.translation[1] = (transform.translation[1] + scaled_amount)
          .min(ARENA_HEIGHT - PADDLE_HEIGHT * 0.5)
          .max(PADDLE_HEIGHT * 0.5);
      }
    }
  }
# }
</code></pre>
<p>Note: For the above to work, we'll have to mark <code>PADDLE_HEIGHT</code> and <code>ARENA_HEIGHT</code>
as being public in <code>pong.rs</code>, and then import it in <code>paddle.rs</code>.</p>
<a class="header" href="#summary" id="summary"><h2>Summary</h2></a>
<p>In this chapter, we added an input handler to our game, so that we
could capture keypresses. We then created a system that would interpret these
keypresses, and move our game's paddles accordingly. In the next chapter, we'll
explore another key concept in real-time games: time. We'll make our game aware
of time, and add a ball for our paddles to bounce back and forth.</p>
<a class="header" href="#call-for-contribution" id="call-for-contribution"><h1>Call for contribution</h1></a>
<p>And... that's where the pong chapter ends.
Amethyst is still in development and writing good tutorials is hard, so the guide is not complete yet.
We are sorry this might feel a bit disappointing.</p>
<p>Fortunately, the pong example is complete, and you can find the entire code with balls, score and music on the example pages available <a href="https://www.amethyst.rs/doc">here</a>. You can get additional help by leaving a post on <a href="https://www.reddit.com/r/Amethyst">our subreddit</a> or on our <a href="https://discord.gg/GnP5Whs">Discord server</a>.</p>
<p>We hate to have an incomplete tutorial as much as you do, and you can help us complete it!
As stated above, the code is ready, tested and working. If you have some experience with the engine and you know how to write a tutorial, you can reach us out and we will help you do it by giving you details on how things work and how to structure it.</p>
<p>Feel free to ping us on Discord or in a GitHub issue!</p>
<a class="header" href="#animation" id="animation"><h1>Animation</h1></a>
<p>Animation in computer graphics can be viewed as controlled mutation of attributes of objects
over time, using a predefined function. Examples of this are:</p>
<ul>
<li>Changing coordinates of vertices — movement, scaling up or down</li>
<li>Changing the hue of a texture — for a &quot;power up&quot; effect</li>
</ul>
<p>To determine the values each attribute should have at a particular point in time, we define
a set of known values at certain points in the animation — called key frames —
and a function to interpolate the value for the attribute.</p>
<p>This section will guide you in learning how to make use of the animation functionality in Amethyst.</p>
<a class="header" href="#interpolation" id="interpolation"><h1>Interpolation</h1></a>
<p>Interpolation is the calculation of an attribute value that lies in between two key frames.</p>
<p>For example, if an object should move in a circle, then we can define an animation that mutates
its X and Y coordinate attributes.</p>
<p>The animation definition can represent this using 5 key frames:</p>
<table><thead><tr><th> Key Frame # </th><th> X coordinate </th><th> Y coordinate </th></tr></thead><tbody>
<tr><td> 0           </td><td>          0.0 </td><td>          1.0 </td></tr>
<tr><td> 1           </td><td>          1.0 </td><td>          0.0 </td></tr>
<tr><td> 2           </td><td>          0.0 </td><td>         -1.0 </td></tr>
<tr><td> 3           </td><td>         -1.0 </td><td>          0.0 </td></tr>
<tr><td> 4           </td><td>          0.0 </td><td>          1.0 </td></tr>
</tbody></table>
<a class="header" href="#non-interpolation" id="non-interpolation"><h2>Non-interpolation</h2></a>
<p>For a perfect circle, the values in between the key frames can be calculated by the <code>sin(..)</code>
function for the X coordinate, and the <code>cos(..)</code> function for the Y coordinate. So, if we
were trying to calculate what the coordinates should be when <code>t = 0.5</code>, we could go <code>sin( 0.5 * π )</code>.</p>
<p>However, what if we <strong>do not</strong> have such perfect coordinate control, and we only have
the values at the specified key frames?</p>
<a class="header" href="#interpolation-1" id="interpolation-1"><h2>Interpolation</h2></a>
<p>To move in a circle, the X coordinate first increases with a larger step, and the step size
decreases as it approaches the circle boundary on the X axis, where it then flips, and
increases in the negative direction. For the Y coordinate, the magnitude of the step
size increases downwards, then decreases once it has gotten past the halfway point.</p>
<p>The changing step size means, given the first two key frames, 0 and 1, the values do
not change in constant step increments — <em>linear</em>ly (<a href="https://en.wikipedia.org/wiki/Linear_interpolation">LERP</a>) —,
but <em>spherical linear</em>ly (<a href="https://en.wikipedia.org/wiki/Slerp">SLERP</a>).</p>
<p>The spherical linear function is a way of saying, given these two key frame values,
and some proportion of time between the two key frames, what should the actual value
be given that the step increments change as they would on a sphere?</p>
<a class="header" href="#interpolation-functions" id="interpolation-functions"><h2>Interpolation Functions</h2></a>
<p>In computer graphics, there are a number of methods commonly used to calculate the interpolated
values. The following functions are available in Amethyst, implemented by the
<a href="https://crates.io/crates/minterpolate"><code>minterpolate</code></a> library, namely:</p>
<ul>
<li>Linear</li>
<li>SphericalLinear</li>
<li>Step</li>
<li>CatmullRomSpline</li>
<li>CubicSpline</li>
</ul>
<p>Amethyst also allows you to specify your own custom interpolation function.</p>
<a class="header" href="#channel" id="channel"><h1>Channel</h1></a>
<p>An independent grouping or type of functions that operate on attributes of a component.</p>
<p>Some attributes may be mutated by different functions. These functions can be independent of each other, or they may also be dependent each other. An example of these are translation, scaling, and rotation.</p>
<p>Given the following functions are part of the same animation:</p>
<ul>
<li>Translate the object to the right</li>
<li>Translate the object upwards</li>
<li>Scale the object up</li>
</ul>
<p>We want to be able to individually apply related functions, i.e. &quot;apply all translations&quot;, &quot;apply all scalings&quot;, and &quot;apply all rotations&quot;. Each of these groupings is called a <strong>channel</strong>.</p>
<a class="header" href="#sampler" id="sampler"><h1>Sampler</h1></a>
<p>In Amethyst, a <code>Sampler</code> is the lowest level working block of an animation. It defines the interpolation function, and what attribute or set of attributes the function mutates.</p>
<p>The <code>input</code> holds the timing of the key frames. The <code>output</code> holds the values used in the interpolation function for each of the key frames.</p>
<p>You can imagine the interpolation function as <code>fn(Time) -&gt; ChannelValue</code></p>
<a class="header" href="#definition" id="definition"><h1>Definition</h1></a>
<p>Animations can be defined for objects made of a single entity, or complex objects made up of multiple entities.</p>
<p>Right now we do not have a tutorial for defining an animation from scratch, but take a look at the following resources to get an idea of how to write one:</p>
<ul>
<li><a href="https://github.com/amethyst/amethyst/tree/master/examples/animation">animation example</a></li>
<li><a href="https://github.com/amethyst/amethyst/tree/master/examples/gltf">gltf example</a></li>
<li><a href="https://docs.rs/amethyst_animation">API docs</a></li>
</ul>
<a class="header" href="#custom-gamedata" id="custom-gamedata"><h1>Custom <code>GameData</code></h1></a>
<p>So far we've been using the <code>Amethyst</code> supplied <code>GameData</code> struct to handle
our <code>System</code>s. This works well for smaller games and demos, but once we
start building a larger game, we will quickly realise we need to
manipulate the <code>System</code> dispatch based on game <code>State</code>, or we need to pass
data between <code>State</code>s that aren't <code>Send + Sync</code> which can't be added to <code>World</code>.</p>
<p>The solution to our troubles here is to create a custom <code>GameData</code> structure
to house what we need that can not be added to <code>World</code>.</p>
<p>In this tutorial we will look at how one could structure a <code>Paused</code> <code>State</code>,
which disables the game logic, only leaving a few core systems running that
are essential (like rendering, input and UI).</p>
<p>Let's start by creating the <code>GameData</code> structure:</p>
<pre><code class="language-rust ignore">pub struct CustomGameData&lt;'a, 'b&gt; {
    core_dispatcher: Dispatcher&lt;'a, 'b&gt;,
    running_dispatcher: Dispatcher&lt;'a, 'b&gt;,
}
</code></pre>
<p>We also add a utility function for performing dispatch:</p>
<pre><code class="language-rust ignore">impl&lt;'a, 'b&gt; CustomGameData&lt;'a, 'b&gt; {
    /// Update game data
    pub fn update(&amp;mut self, world: &amp;World, running: bool) {
        if running {
            self.running_dispatcher.dispatch(&amp;world.res);
        }
        self.core_dispatcher.dispatch(&amp;world.res);
    }
}
</code></pre>
<p>To be able to use this structure with <code>Amethyst</code>s <code>Application</code> we need to create
a builder that implements <code>DataInit</code>. This is the only requirement placed on the
<code>GameData</code> structure.</p>
<pre><code class="language-rust ignore">use amethyst::core::ArcThreadPool;

pub struct CustomGameDataBuilder&lt;'a, 'b&gt; {
    pub core: DispatcherBuilder&lt;'a, 'b&gt;,
    pub running: DispatcherBuilder&lt;'a, 'b&gt;,
}

impl&lt;'a, 'b&gt; Default for CustomGameDataBuilder&lt;'a, 'b&gt; {
    fn default() -&gt; Self {
        CustomGameDataBuilder::new()
    }
}

impl&lt;'a, 'b&gt; CustomGameDataBuilder&lt;'a, 'b&gt; {
    pub fn new() -&gt; Self {
        CustomGameDataBuilder {
            core: DispatcherBuilder::new(),
            running: DispatcherBuilder::new(),
        }
    }

    pub fn with_base_bundle&lt;B&gt;(mut self, bundle: B) -&gt; Result&lt;Self&gt;
    where
        B: SystemBundle&lt;'a, 'b&gt;,
    {
        bundle
            .build(&amp;mut self.core)
            .map_err(|err| Error::Core(err))?;
        Ok(self)
    }

    pub fn with_running&lt;S&gt;(mut self, system: S, name: &amp;str, dependencies: &amp;[&amp;str]) -&gt; Self
    where
        for&lt;'c&gt; S: System&lt;'c&gt; + Send + 'a,
    {
        self.running.add(system, name, dependencies);
        self
    }
}

impl&lt;'a, 'b&gt; DataInit&lt;CustomGameData&lt;'a, 'b&gt;&gt; for CustomGameDataBuilder&lt;'a, 'b&gt; {
    fn build(self, world: &amp;mut World) -&gt; CustomGameData&lt;'a, 'b&gt; {
        // Get a handle to the `ThreadPool`.
        let pool = world.read_resource::&lt;ArcThreadPool&gt;().clone();

        let mut core_dispatcher = self.core.with_pool(pool.clone()).build();
        let mut running_dispatcher = self.running.with_pool(pool.clone()).build();
        core_dispatcher.setup(&amp;mut world.res);
        running_dispatcher.setup(&amp;mut world.res);

        CustomGameData { core_dispatcher, running_dispatcher }
    }
}
</code></pre>
<p>We can now use <code>CustomGameData</code> in place of the provided <code>GameData</code> when building
our <code>Application</code>, but first we should create some <code>State</code>s.</p>
<pre><code class="language-rust ignore">struct Main;
struct Paused;

impl&lt;'a, 'b&gt; State&lt;CustomGameData&lt;'a, 'b&gt;, StateEvent&gt; for Paused {
    fn on_start(&amp;mut self, data: StateData&lt;CustomGameData&gt;) {
        create_paused_ui(data.world);
    }

    fn handle_event(
        &amp;mut self,
        data: StateData&lt;CustomGameData&gt;,
        event: StateEvent&gt;,
    ) -&gt; Trans&lt;CustomGameData&lt;'a, 'b&gt;, StateEvent&gt; {
        if let StateEvent::Window(event) = &amp;event {
            if is_close_requested(&amp;event) || is_key_down(&amp;event, VirtualKeyCode::Escape) {
                Trans::Quit
            } else if is_key_down(&amp;event, VirtualKeyCode::Space) {
                delete_paused_ui(data.world);
                Trans::Pop
            } else {
                Trans::None
            }
        } else {
            Trans::None
        }
    }

    fn update(&amp;mut self, data: StateData&lt;CustomGameData&gt;) -&gt; Trans&lt;CustomGameData&lt;'a, 'b&gt;, StateEvent&gt; {
        data.data.update(&amp;data.world, false); // false to say we should not dispatch running
        Trans::None
    }
}

impl&lt;'a, 'b&gt; State&lt;CustomGameData&lt;'a, 'b&gt;, StateEvent&gt; for Main {
    fn on_start(&amp;mut self, data: StateData&lt;CustomGameData&gt;) {
        initialise(data.world);
    }

    fn handle_event(
        &amp;mut self,
        _: StateData&lt;CustomGameData&gt;,
        event: StateEvent,
    ) -&gt; Trans&lt;CustomGameData&lt;'a, 'b&gt;, StateEvent&gt; {
        if let StateEvent::Window(event) = &amp;event {
            if is_close_requested(&amp;event) || is_key_down(&amp;event, VirtualKeyCode::Escape) {
                Trans::Quit
            } else if is_key_down(&amp;event, VirtualKeyCode::Space) {
                Trans::Push(Box::new(Paused))
            } else {
                Trans::None
            }
        } else {
            Trans::None
        }
    }

    fn update(&amp;mut self, data: StateData&lt;CustomGameData&gt;) -&gt; Trans&lt;CustomGameData&lt;'a, 'b&gt;, StateEvent&gt; {
        data.data.update(&amp;data.world, true); // true to say we should dispatch running
        Trans::None
    }
}
</code></pre>
<p>The only thing that remains now is to use our <code>CustomGameDataBuilder</code> when building the
<code>Application</code>.</p>
<pre><code class="language-rust ignore">    let game_data = CustomGameDataBuilder::default()
        .with_running::&lt;ExampleSystem&gt;(ExampleSystem, &quot;example_system&quot;, &amp;[])
        .with_base_bundle(TransformBundle::new())?
        .with_base_bundle(UiBundle::&lt;String, String&gt;::new())?
        .with_base_bundle(RenderBundle::new(pipeline_builder, Some(display_config)))?
        .with_base_bundle(InputBundle::&lt;String, String&gt;::new())?;

    let mut game = Application::new(resources_directory, Main, game_data)?;
    game.run();
</code></pre>
<p>Those are the basics of creating a custom <code>GameData</code> structure. Now get out there and
build your game!</p>
<a class="header" href="#sprites" id="sprites"><h1>Sprites</h1></a>
<p>Sprites are 2D images that represent an object or background. Sprites are represented by two main chunks of data:</p>
<ul>
<li><strong>Texture:</strong> The image made of pixels.</li>
<li><strong>Sprite Layout:</strong> The (rectangular) coordinates of the sprites on that image.</li>
</ul>
<p>In Amethyst, these are represented by the <a href="https://www.amethyst.rs/doc/latest/doc/amethyst_renderer/struct.Texture.html"><code>Texture</code></a> and <a href="https://www.amethyst.rs/doc/latest/doc/amethyst_renderer/struct.SpriteSheet.html"><code>SpriteSheet</code></a> types respectively. The pages in this section will explain how to set up your application to load and display sprites.</p>
<blockquote>
<p><strong>Note:</strong> The code snippets in this section explain the parts of setting up sprite rendering separately. For complete application examples, please refer to the <a href="https://github.com/amethyst/amethyst/tree/master/examples/sprites"><em>sprites</em></a> or <a href="https://github.com/amethyst/amethyst/tree/master/examples/sprites_ordered"><em>sprites_ordered</em></a> examples in the <a href="https://github.com/amethyst/amethyst/tree/master/examples">examples</a> directory.</p>
</blockquote>
<a class="header" href="#set-up-the-render-pass" id="set-up-the-render-pass"><h1>Set Up The Render Pass</h1></a>
<p>Amethyst supports drawing sprites using the <code>DrawSprite</code> render pass. To enable this you have to do the following:</p>
<ol>
<li>Build a <code>Pipeline</code> with the <code>DrawSprite</code> pass. If your sprites have transparent pixels use the <code>.with_transparency(..)</code> method.</li>
<li>Use the <code>.with_sprite_sheet_processor()</code> method on the <code>RenderBundle</code>.</li>
</ol>
<pre><code class="language-rust no_run noplaypen"># extern crate amethyst;
#
# use amethyst::core::transform::TransformBundle;
# use amethyst::input::InputBundle;
# use amethyst::prelude::*;
use amethyst::renderer::{
    ColorMask, DisplayConfig, DrawSprite, Pipeline, RenderBundle, Stage, ALPHA,
};
# use amethyst::ui::UiBundle;
# use amethyst::utils::application_root_dir;
#
# #[derive(Debug, Default)]
# struct ExampleState;
#
# impl&lt;'a, 'b&gt; SimpleState&lt;'a, 'b&gt; for ExampleState {}

fn main() -&gt; amethyst::Result&lt;()&gt; {
#     amethyst::start_logger(Default::default());
#     let app_root = application_root_dir();
#     let display_config = DisplayConfig::load(format!(
#         &quot;{}/examples/sprites/resources/display_config.ron&quot;,
#         app_root
#     ));
#
    // ...

    let pipe = Pipeline::build().with_stage(
        Stage::with_backbuffer()
            .clear_target([0., 0., 0., 1.], 1.)
            .with_pass(
                DrawSprite::new()
                    .with_transparency(ColorMask::all(), ALPHA, None)),
    );

    let game_data = GameDataBuilder::default()
#         .with_bundle(TransformBundle::new())?
        .with_bundle(
            RenderBundle::new(pipe, Some(display_config))
                .with_sprite_sheet_processor())?

#         .with_bundle(InputBundle::&lt;String, String&gt;::new())?
#         .with_bundle(UiBundle::&lt;String, String&gt;::new())?;
    // ...
#     let assets_directory = format!(&quot;{}/examples/assets/&quot;, app_root);
#     let mut game = Application::new(assets_directory, ExampleState::default(), game_data)?;
#     game.run();
#
#     Ok(())
}
</code></pre>
<a class="header" href="#load-the-texture" id="load-the-texture"><h1>Load The <code>Texture</code></h1></a>
<p>The first part of loading sprites into Amethyst is to read the image into memory. Currently Amethyst supports <a href="https://www.amethyst.rs/doc/latest/doc/amethyst_renderer/struct.PngFormat.html"><code>PngFormat</code></a>, <a href="https://www.amethyst.rs/doc/latest/doc/amethyst_renderer/struct.BmpFormat.html"><code>BmpFormat</code></a>, <a href="https://www.amethyst.rs/doc/latest/doc/amethyst_renderer/struct.JpgFormat.html"><code>JpgFormat</code></a> and <a href="https://www.amethyst.rs/doc/latest/doc/amethyst_renderer/struct.TgaFormat.html"><code>TgaFormat</code></a>.</p>
<p>The following snippet shows how to load a PNG image:</p>
<pre><code class="language-rust no_run noplaypen"># extern crate amethyst;
use amethyst::assets::{AssetStorage, Loader};
use amethyst::prelude::*;
use amethyst::renderer::{MaterialTextureSet, PngFormat, Texture, TextureMetadata, TextureHandle};

pub fn load_texture&lt;N&gt;(name: N, world: &amp;World) -&gt; TextureHandle
where
    N: Into&lt;String&gt;,
{
    let loader = world.read_resource::&lt;Loader&gt;();
    loader.load(
        name,
        PngFormat,
        TextureMetadata::srgb(),
        (),
        &amp;world.read_resource::&lt;AssetStorage&lt;Texture&gt;&gt;(),
    )
}

#[derive(Debug)]
struct ExampleState;

impl&lt;'a, 'b&gt; SimpleState&lt;'a, 'b&gt; for ExampleState {
    fn on_start(&amp;mut self, data: StateData&lt;GameData&gt;) {
        let texture_handle = load_texture(&quot;texture/sprite_sheet.png&quot;, &amp;data.world);

        let texture_id = 0;
        data.world
            .write_resource::&lt;MaterialTextureSet&gt;()
            .insert(texture_id, texture_handle);
    }
}
#
# fn main() {}
</code></pre>
<p>There are two things that may surprise you.</p>
<ul>
<li>
<p>Firstly, you don't get back the <a href="https://www.amethyst.rs/doc/latest/doc/amethyst_renderer/struct.Texture.html"><code>Texture</code></a>, but a <a href="https://www.amethyst.rs/doc/latest/doc/amethyst_renderer/type.TextureHandle.html"><code>TextureHandle</code></a>, which is a cloneable reference to the texture.</p>
<p>When you use <a href="https://www.amethyst.rs/doc/latest/doc/amethyst_assets/struct.Loader.html#method.load"><code>loader.load(..)</code></a> to load an <a href="https://www.amethyst.rs/doc/latest/doc/amethyst_assets/trait.Asset.html"><code>Asset</code></a>, the method returns immediately with a unique handle for your texture. The actual asset loading is handled asynchronously, so if you attempt to use the texture handle to retrieve the texture, such as with <a href="https://www.amethyst.rs/doc/latest/doc/specs/world/struct.World.html#method.read_resource"><code>world.read_resource::&lt;AssetStorage&lt;Texture&gt;&gt;()</code></a><a href="https://www.amethyst.rs/doc/latest/doc/amethyst_assets/struct.AssetStorage.html#method.get"><code>.get(texture_handle)</code></a>, you will get a <code>None</code> until the <code>Texture</code> has finished loading.</p>
</li>
<li>
<p>Secondly, you have to insert the texture into a <code>MaterialTextureSet</code>, with an arbitrary <code>u64</code> ID.</p>
<p>The ID is necessary to link the <a href="https://www.amethyst.rs/doc/latest/doc/amethyst_renderer/struct.Texture.html"><code>Texture</code></a> (loaded image) to the <a href="https://www.amethyst.rs/doc/latest/doc/amethyst_renderer/struct.SpriteSheet.html"><code>SpriteSheet</code></a> (layout data), which takes the texture ID instead of the handle.</p>
<p>You pick the texture ID based on how you want to reference it. For example, you might have an application configuration that says <code>path/to/spritesheet_0.png</code> is ID <code>100</code>, <code>path/to/spritesheet_1.png</code> is ID <code>101</code>, so you can use that. Or, you might do something clever like calculate an ID based on the path, and if it's already loaded, then you know you don't have to load it again.</p>
</li>
</ul>
<p>The loaded texture will use linear filter, e.g. screen pixels will be linearly interpolated between the closest image pixels. In layman's terms, if your images have small resolution, sprites will look blury. Use <code>TextureMetadata::srgb_scale()</code> instead to avoid such effect. Screen pixel will be taken from nearest pixel of texture in that case.</p>
<a class="header" href="#define-the-spritesheet" id="define-the-spritesheet"><h1>Define The <code>SpriteSheet</code></h1></a>
<p>With the texture loaded, Amethyst still needs to know <em>where the sprites are</em> on the image.
There are two ways to load a sprite sheet definition: from a file or from code.</p>
<a class="header" href="#load-the-sheet-from-a-file" id="load-the-sheet-from-a-file"><h2>Load the sheet from a file</h2></a>
<p>The easiest way to load your sprites is to use a sprite sheet definition ron file.
Here is an example of such a definition file:</p>
<pre><code class="language-text ignore">(
    // Width of the sprite sheet
    spritesheet_width: 48.0,
    // Height of the sprite sheet
    spritesheet_height: 16.0,
    // List of sprites the sheet holds
    sprites: [
        (
            // Horizontal position of the sprite in the sprite sheet
            x: 0.0,
            // Vertical position of the sprite in the sprite sheet
            y: 0.0,
            // Width of the sprite
            width: 16.0, 
            // Height of the sprite
            height: 16.0, 
            // Number of pixels to shift the sprite to the left and down relative to the entity holding it when rendering
            offsets: (0.0, 0.0), // This is optional and defaults to (0.0, 0.0)
        ),
        (
            x: 16.0,
            y: 0.0,
            width: 32.0,
            height: 16.0,
        ),
        // etc...
    ],
)
</code></pre>
<p>Then, you can load it using the texture ID of the sheet's image you loaded earlier:</p>
<pre><code class="language-rust no_run noplaypen"># extern crate amethyst;
# use amethyst::assets::{Loader, AssetStorage};
# use amethyst::renderer::{SpriteSheetFormat, SpriteSheet};
# 
# const SPRITESHEET_TEXTURE_ID: u64 = 0;
# 
# fn load_sprite_sheet() {
#   let world = amethyst::ecs::World::new(); // Normally, you would use Amethyst's world
#   let loader = world.read_resource::&lt;Loader&gt;();
#   let spritesheet_storage = world.read_resource::&lt;AssetStorage&lt;SpriteSheet&gt;&gt;();
let spritesheet_handle = loader.load(
    &quot;my_spritesheet.ron&quot;,
    SpriteSheetFormat,
    SPRITESHEET_TEXTURE_ID,
    (),
    &amp;spritesheet_storage,
);
# }
</code></pre>
<p>This will get you the <code>SpriteSheetHandle</code> you will then use to draw the sprites.</p>
<a class="header" href="#load-the-sheet-from-code" id="load-the-sheet-from-code"><h2>Load the sheet from code</h2></a>
<p>While it is not the recommended way, it is also possible to manually build your sheet with code.</p>
<p>Importantly, <strong>we use pixel coordinates as well as texture coordinates</strong> to define the sprite layout. Pixel coordinates indicate the dimensions of the sprite to draw on screen; texture coordinates indicate which part of the image contains the sprite, and are expressed as a proportion of the image.</p>
<p>The following table lists the differences between the coordinate systems:</p>
<table><thead><tr><th> Pixel coordinates                     </th><th> Texture coordinates                       </th></tr></thead><tbody>
<tr><td> Begin at the top left of the image    </td><td> Begin at the bottom left of the image     </td></tr>
<tr><td> Increase to the right and down        </td><td> Increase to the right and up              </td></tr>
<tr><td> Range from 0 to (width or height - 1) </td><td> Range from 0.0 to 1.0                     </td></tr>
<tr><td> Use pixel values at exact coordinates </td><td> Takes average value of surrounding pixels </td></tr>
</tbody></table>
<p>In Amethyst, pixel dimensions and texture coordinates are stored in the <code>Sprite</code> struct. Since texture coordinates can be derived from pixel coordinates, Amethyst provides the <code>Sprite::from_pixel_values</code> function to create a <code>Sprite</code>.</p>
<p>The following snippet shows you how to naively define a <code>SpriteSheet</code>. In a real application, you would typically use the sprite sheet from file feature, which is much more convenient.</p>
<pre><code class="language-rust no_run noplaypen"># extern crate amethyst;
use amethyst::renderer::{Sprite, SpriteSheet, TextureCoordinates};

/// Returns a `SpriteSheet`.
///
/// # Parameters
///
/// * `texture_id`: ID of the texture in the `MaterialTextureSet`.
pub fn load_sprite_sheet(texture_id: u64) -&gt; SpriteSheet {
    let sprite_count = 1; // number of sprites
    let mut sprites = Vec::with_capacity(sprite_count);

    let image_w = 100;
    let image_h = 20;
    let sprite_w = 10;
    let sprite_h = 10;

    // Here we are loading the 5th sprite on the bottom row.
    let offset_x = 50; // 5th sprite * 10 pixel sprite width
    let offset_y = 10; // Second row (1) * 10 pixel sprite height
    let offsets = [5; 2]; // Align the sprite with the middle of the entity.

    let sprite = Sprite::from_pixel_values(
        image_w, image_h, sprite_w, sprite_h, offset_x, offset_y, offsets,
    );
    sprites.push(sprite);

    SpriteSheet {
        texture_id,
        sprites,
    }
}
</code></pre>
<a class="header" href="#spriterender-component" id="spriterender-component"><h1><code>SpriteRender</code> Component</h1></a>
<p>After loading the <code>SpriteSheet</code>, you need to attach it to an entity using the <code>SpriteRender</code> component and indicate which sprite to draw. The <code>SpriteRender</code> component looks like this:</p>
<pre><code class="language-rust ignore">#[derive(Clone, Debug, PartialEq)]
pub struct SpriteRender {
    /// Handle to the sprite sheet of the sprite
    pub sprite_sheet: SpriteSheetHandle,
    /// Index of the sprite on the sprite sheet
    pub sprite_number: usize,
    /// Whether the sprite should be flipped horizontally
    pub flip_horizontal: bool,
    /// Whether the sprite should be flipped vertically
    pub flip_vertical: bool,
}
</code></pre>
<p>The <code>flip_*</code> fields indicate whether the sprite to be drawn should be flipped. The sprite number is the index of the sprite loaded in the sprite sheet. What's left is the <code>SpriteSheetHandle</code>.</p>
<p>In the previous section you wrote a function that returns a <code>SpriteSheet</code>. This can be turned into a <code>SpriteSheetHandle</code> using the <code>Loader</code> resource as follows:</p>
<pre><code class="language-rust no_run noplaypen"># extern crate amethyst;
use amethyst::assets::{AssetStorage, Loader};
# use amethyst::prelude::*;
use amethyst::renderer::{
    MaterialTextureSet, SpriteSheet, SpriteSheetHandle, TextureHandle,
};

# pub fn load_texture&lt;N&gt;(name: N, world: &amp;World) -&gt; TextureHandle
# where
#     N: Into&lt;String&gt;,
# {
#     unimplemented!();
# }
#
# pub fn load_sprite_sheet(texture_id: u64) -&gt; SpriteSheet {
#     unimplemented!();
# }
#[derive(Debug)]
struct ExampleState;

impl&lt;'a, 'b&gt; SimpleState&lt;'a, 'b&gt; for ExampleState {
    fn on_start(&amp;mut self, mut data: StateData&lt;GameData&gt;) {
#         let texture_handle = load_texture(&quot;texture/sprite_sheet.png&quot;, &amp;data.world);
#         let texture_id = 0;
#         data.world
#             .write_resource::&lt;MaterialTextureSet&gt;()
#             .insert(texture_id, texture_handle);
        // ...

        let sprite_sheet = load_sprite_sheet(texture_id);
        let sprite_sheet_handle = {
            let loader = data.world.read_resource::&lt;Loader&gt;();
            loader.load_from_data(
                sprite_sheet,
                (),
                &amp;data.world.read_resource::&lt;AssetStorage&lt;SpriteSheet&gt;&gt;(),
            )
        };
    }
}
#
# fn main() {}
</code></pre>
<p>Cool, finally we have all the parts, let's build a <code>SpriteRender</code> and attach it to an entity:</p>
<pre><code class="language-rust no_run noplaypen"># extern crate amethyst;
# use amethyst::assets::{AssetStorage, Loader};
use amethyst::core::cgmath::Vector3;
use amethyst::core::transform::Transform;
# use amethyst::prelude::*;
use amethyst::renderer::{
    MaterialTextureSet, ScreenDimensions, SpriteRender, SpriteSheet,
    SpriteSheetHandle, TextureHandle, Transparent
};

# pub fn load_texture&lt;N&gt;(name: N, world: &amp;World) -&gt; TextureHandle
# where
#     N: Into&lt;String&gt;,
# {
#     unimplemented!();
# }
#
# pub fn load_sprite_sheet(texture_id: u64) -&gt; SpriteSheet {
#     unimplemented!();
# }
#[derive(Debug)]
struct ExampleState;

impl&lt;'a, 'b&gt; SimpleState&lt;'a, 'b&gt; for ExampleState {
    fn on_start(&amp;mut self, mut data: StateData&lt;GameData&gt;) {
#         let texture_handle = load_texture(&quot;texture/sprite_sheet.png&quot;, &amp;data.world);
#         let texture_id = 0;
#         data.world
#             .write_resource::&lt;MaterialTextureSet&gt;()
#             .insert(texture_id, texture_handle);
# 
#         let sprite_sheet = load_sprite_sheet(texture_id);
#         let sprite_sheet_handle = {
#             let loader = data.world.read_resource::&lt;Loader&gt;();
#             loader.load_from_data(
#                 sprite_sheet,
#                 (),
#                 &amp;data.world.read_resource::&lt;AssetStorage&lt;SpriteSheet&gt;&gt;(),
#             )
#         };
        // ...

        self.initialize_sprite(&amp;mut data.world, sprite_sheet_handle);
    }
}

impl ExampleState {
    fn initialize_sprite(
        &amp;mut self,
        world: &amp;mut World,
        sprite_sheet_handle: SpriteSheetHandle,
    ) {
        let (width, height) = {
            let dim = world.read_resource::&lt;ScreenDimensions&gt;();
            (dim.width(), dim.height())
        };

        // Move the sprite to the middle of the window
        let mut sprite_transform = Transform::default();
        sprite_transform.translation = Vector3::new(width / 2., height / 2., 0.);

        let sprite_render = SpriteRender {
            sprite_sheet: sprite_sheet_handle,
            sprite_number: 0, // First sprite
            flip_horizontal: false,
            flip_vertical: false,
        };

        world
            .create_entity()
            .with(sprite_render)
            .with(sprite_transform)
            .with(Transparent) // If your sprite is transparent
            .build();
    }
}
#
# fn main() {}
</code></pre>
<p>Got that? Sweet!</p>
<a class="header" href="#orthographic-camera" id="orthographic-camera"><h1>Orthographic Camera</h1></a>
<p>Finally, you need to tell Amethyst to draw in 2D space. This is done by creating an entity with a <code>Camera</code> component using orthographic projection. For more information about orthographic projection, refer to the <a href="https://opengl-notes.readthedocs.io/en/latest/topics/transforms/viewing.html#orthographic-projection">OpenGL documentation</a>.</p>
<p>The following snippet demonstrates how to set up a <code>Camera</code> that sees entities within screen bounds, where the entities' Z position is between -10.0 and 10.0:</p>
<pre><code class="language-rust no_run noplaypen"># extern crate amethyst;
use amethyst::core::cgmath::{Ortho, Vector3};
use amethyst::core::transform::Transform;
# use amethyst::prelude::*;
use amethyst::renderer::{
    Camera, Projection, ScreenDimensions
};

#[derive(Debug)]
struct ExampleState;

impl&lt;'a, 'b&gt; SimpleState&lt;'a, 'b&gt; for ExampleState {
    fn on_start(&amp;mut self, mut data: StateData&lt;GameData&gt;) {
        // ...

        self.initialize_camera(&amp;mut data.world);
    }
}

impl ExampleState {
    fn initialize_camera(&amp;mut self, world: &amp;mut World) {
        let (width, height) = {
            let dim = world.read_resource::&lt;ScreenDimensions&gt;();
            (dim.width(), dim.height())
        };

        // Translate the camera to Z coordinate 10.0, and it looks back toward
        // the origin with depth 20.0
        let mut transform = Transform::default();
        transform.translation = Vector3::new(0., 0., 10.);

        let camera = world
            .create_entity()
            .with(transform)
            .with(Camera::from(Projection::Orthographic(Ortho {
                left: 0.0,
                right: width,
                top: height,
                bottom: 0.0,
                near: 0.0,
                far: 20.0,
            })))
            .build();
    }
}
</code></pre>
<p>And you're done! If you would like to see this in practice, check out the <a href="https://github.com/amethyst/amethyst/tree/master/examples/sprites"><em>sprites</em></a> or <a href="https://github.com/amethyst/amethyst/tree/master/examples/sprites_ordered"><em>sprites_ordered</em></a> examples in the <a href="https://github.com/amethyst/amethyst/tree/master/examples">examples</a> directory.</p>
<a class="header" href="#prefabs" id="prefabs"><h1>Prefabs</h1></a>
<p>A <code>Prefab</code> in Amethyst is at the core a simple list of future entities, where each entry in
the list consists of two pieces of optional data:</p>
<ul>
<li>a parent index that refers to a different entry in the list</li>
<li>a data collection implementing the trait <code>PrefabData</code></li>
</ul>
<p>To instantiate a <code>Prefab</code>, we put a <code>Handle&lt;Prefab&lt;T&gt;&gt;</code> on an <code>Entity</code>. The <code>Entity</code> we put
the <code>Handle</code> on is referred to as the main <code>Entity</code>, and the first entry in the list inside a
<code>Prefab</code> refers to this <code>Entity</code>. All other entries in the list will spawn a new <code>Entity</code> on
instantiation.</p>
<p>NOTE: This means that we currently cannot target multiple existing entities from a single <code>Prefab</code>.
This restriction is likely to be removed in the future.</p>
<p>The lifetime of a <code>Prefab</code> can roughly be divided into three distinct parts:</p>
<p><strong>Loading</strong></p>
<p>This is the same as for all assets in Amethyst, the user initiates a load using <code>Loader</code>, a
<code>Source</code> and a <code>Format</code>. The <code>Format</code> returns a <code>Prefab</code>, and the user is handed a <code>Handle&lt;Prefab&lt;T&gt;&gt;</code>,
for some <code>T</code> that implements <code>PrefabData</code>.</p>
<p><strong>Sub asset loading</strong></p>
<p>A <code>PrefabData</code> implementation could refer to other assets that need to be loaded asynchronously, and
we don't want the user get a <code>Complete</code> notification on their <code>Progress</code> before everything has been
loaded.</p>
<p>Because of this, once the <code>Format</code> have loaded the <code>Prefab</code> from the <code>Source</code>, and a <code>PrefabLoaderSystem</code>
runs <code>process</code> on the <code>AssetStorage</code>, the system will invoke the <code>load_sub_assets</code> function on the
<code>PrefabData</code> implementation. If any asset loads are triggered during this, they must adhere to the following
rules:</p>
<ul>
<li>the given <code>ProgressCounter</code> must be used as a parameter to the load function on <code>Loader</code>, so load tracking
works correctly</li>
<li>the function must return <code>Ok(true)</code> (unless an <code>Error</code> occurred)</li>
</ul>
<p>Note that during this phase the <code>PrefabData</code> is mutable, which means it can morph inside the <code>Prefab</code>. An
example of this is the <code>AssetPrefab</code>, which will morph into <code>AssetPrefab::Handle</code>.</p>
<p>Once all sub asset loading is finished, which the <code>PrefabLoaderSystem</code> will track using the <code>ProgressCounter</code>,
a <code>Complete</code> signal will be sent upwards.</p>
<p><strong>Prefab instantiation</strong></p>
<p>This stage happens after the <code>Prefab</code> has been fully loaded and <code>Complete</code> has been signaled, and the
<code>Handle&lt;Prefab&lt;T&gt;&gt;</code> is put on an <code>Entity</code>. At this point we know that all internal data has been loaded,
and all sub assets have been processed. The <code>PrefabLoaderSystem</code> will then walk through the <code>Prefab</code> data
immutably and create a new <code>Entity</code> for all but the first entry in the list, and then for each instance
of <code>PrefabData</code> call the <code>add_to_entity</code> function.</p>
<p>Note that for prefabs that reference other prefabs, to make instantiation be performed inside a single frame,
lower level <code>PrefabLoaderSystem</code>s need to depend on the higher level ones. To see how this works out check the gltf
example, where we have a scene prefab, and the gltf loader (which use the prefab system internally).</p>
<a class="header" href="#prefabdata" id="prefabdata"><h2><code>PrefabData</code></h2></a>
<p>Ok, so what would a simple implementation of <code>PrefabData</code> look like?</p>
<p>Let's take a look at the implementation for <code>Transform</code>, which is a core concept in Amethyst:</p>
<pre><code class="language-rust no_run noplaypen"># extern crate amethyst;
# use amethyst::assets::PrefabData;
# use amethyst::ecs::{WriteStorage, Entity, Component, NullStorage, error::Error as SpecsError};
# 
# // We declare that struct for the sake of automated testing.
# #[derive(Default, Clone)]
# struct Transform;
# impl Component for Transform {
#   type Storage = NullStorage&lt;Transform&gt;;
# }
#
impl&lt;'a&gt; PrefabData&lt;'a&gt; for Transform {
    type SystemData = WriteStorage&lt;'a, Transform&gt;;
    type Result = ();

    fn add_to_entity(
        &amp;self,
        entity: Entity,
        storage: &amp;mut Self::SystemData,
        _: &amp;[Entity],
    ) -&gt; Result&lt;(), SpecsError&gt; {
        storage.insert(entity, self.clone()).map(|_| ())
    }
}
</code></pre>
<p>First, we specify a <code>SystemData</code> type, this is the data required from <code>World</code> in order to load and
instantiate this <code>PrefabData</code>. Here we want to write to both <code>Transform</code> and <code>GlobalTransform</code>,
because <code>Transform</code> won't work without a companion <code>GlobalTransform</code>.</p>
<p>Second, we specify what result the <code>add_to_entity</code> function returns. In our case this is unit <code>()</code>, for
other implementations it could return a <code>Handle</code> etc. For an example of this, look at the <code>TexturePrefab</code>
in the renderer crate.</p>
<p>Next we defined the <code>add_to_entity</code> function, which is used to actually instantiate data. In our case here,
we insert a default <code>GlobalTransform</code> and the local <code>Transform</code> data on the referenced <code>Entity</code>. In this
scenario we aren't using the third parameter to the function. This parameter contains a list of all <code>Entity</code>s
affected by the <code>Prefab</code>, the first entry in the list will be the main <code>Entity</code>, and the rest will be the
<code>Entity</code>s that were created for all the entries in the data list inside the <code>Prefab</code>.</p>
<p>Last of all, we can see that this does not implement <code>load_sub_assets</code>, which is because there
are no secondary assets to load from <code>Source</code> here.</p>
<p>Let's look at a slightly more complex implementation, the <code>AssetPrefab</code>. This <code>PrefabData</code> is used to
load extra <code>Asset</code>s as part of a <code>Prefab</code>:</p>
<pre><code class="language-rust no_run noplaypen"># extern crate amethyst;
# #[macro_use] extern crate serde_derive;
# use amethyst::assets::{Asset, AssetStorage, Loader, Format, Handle, ProgressCounter};
# use amethyst::assets::PrefabData;
# use amethyst::ecs::{WriteStorage, ReadExpect, Read, Entity, error::Error as SpecsError};
# 
#[derive(Deserialize, Serialize)]
pub enum AssetPrefab&lt;A, F&gt;
where
    A: Asset,
    F: Format&lt;A&gt;,
{
    /// From existing handle
    #[serde(skip)]
    Handle(Handle&lt;A&gt;),

    /// From file, (name, format, format options)
    File(String, F, F::Options),
}

impl&lt;'a, A, F&gt; PrefabData&lt;'a&gt; for AssetPrefab&lt;A, F&gt;
where
    A: Asset,
    F: Format&lt;A&gt; + Clone,
    F::Options: Clone,
{
    type SystemData = (
        ReadExpect&lt;'a, Loader&gt;,
        WriteStorage&lt;'a, Handle&lt;A&gt;&gt;,
        Read&lt;'a, AssetStorage&lt;A&gt;&gt;,
    );

    type Result = Handle&lt;A&gt;;

    fn add_to_entity(
        &amp;self,
        entity: Entity,
        system_data: &amp;mut Self::SystemData,
        _: &amp;[Entity],
    ) -&gt; Result&lt;Handle&lt;A&gt;, SpecsError&gt; {
        let handle = match *self {
            AssetPrefab::Handle(ref handle) =&gt; handle.clone(),
            AssetPrefab::File(ref name, ref format, ref options) =&gt; system_data.0.load(
                name.as_ref(),
                format.clone(),
                options.clone(),
                (),
                &amp;system_data.2,
            ),
        };
        system_data.1.insert(entity, handle.clone()).map(|_| handle)
    }

    fn load_sub_assets(
        &amp;mut self,
        progress: &amp;mut ProgressCounter,
        system_data: &amp;mut Self::SystemData,
    ) -&gt; Result&lt;bool, SpecsError&gt; {
        let handle = match *self {
            AssetPrefab::File(ref name, ref format, ref options) =&gt; Some(system_data.0.load(
                name.as_ref(),
                format.clone(),
                options.clone(),
                progress,
                &amp;system_data.2,
            )),
            _ =&gt; None,
        };
        if let Some(handle) = handle {
            *self = AssetPrefab::Handle(handle);
        }
        Ok(true)
    }
}
</code></pre>
<p>So, there are two main differences to this <code>PrefabData</code> compared the <code>Transform</code> example.
The first difference is that the <code>add_to_entity</code> function now return a <code>Handle&lt;A&gt;</code>.
The second difference is that <code>load_sub_assets</code> is implemented, this is because we load
a sub asset. The <code>load_sub_assets</code> function here will do the actual loading, and morph the
internal representation to the <code>AssetPrefab::Handle</code> variant, so when <code>add_to_entity</code> runs later
it will straight up use the internally stored <code>Handle</code>.</p>
<a class="header" href="#special-prefabdata-implementations" id="special-prefabdata-implementations"><h3>Special <code>PrefabData</code> implementations</h3></a>
<p>There are a few special blanket implementations provided by the asset system:</p>
<ul>
<li><code>Option&lt;T&gt;</code> for all <code>T: PrefabData</code>.</li>
<li>Tuples of types that implemented <code>PrefabData</code>, up to a size of 20.</li>
</ul>
<a class="header" href="#working-with-prefabs" id="working-with-prefabs"><h2>Working with <code>Prefab</code>s</h2></a>
<p>So now we know how the <code>Prefab</code> system works on the inside, but how do we use it?</p>
<p>From the point of the user, there are a few parts to using a <code>Prefab</code>:</p>
<ul>
<li>Loading it, using <code>Loader</code> + <code>AssetStorage</code>, or using the helper <code>PrefabLoader</code>, which is a
simple wrapper around the former. For this to work we need a <code>Format</code> that returns <code>Prefab</code>s.</li>
<li>Managing the returned <code>Handle&lt;Prefab&lt;T&gt;&gt;</code>.</li>
<li>Waiting for the <code>Prefab</code> to be fully loaded, using <code>Progress</code>.</li>
<li>Requesting instantiation by placing the <code>Handle&lt;Prefab&lt;T&gt;&gt;</code> on an <code>Entity</code> in the <code>World</code>.</li>
</ul>
<a class="header" href="#prefab-formats" id="prefab-formats"><h2><code>Prefab</code> formats</h2></a>
<p>There are a few provided formats that create <code>Prefab</code>s, some with very specific <code>PrefabData</code>, and
two that are generic:</p>
<ul>
<li><code>RonFormat</code> - this format can be used to load <code>Prefab</code>s in <code>ron</code> format with any <code>PrefabData</code>
that also implements <code>serde::Deserialize</code>.</li>
<li><code>JsonFormat</code> - this format can be used to load <code>Prefab</code>s in <code>Json</code> format with any <code>PrefabData</code>
that also implements <code>serde::Deserialize</code>. It can be enabled with the <code>json</code> feature flag.</li>
<li><code>GltfSceneFormat</code> - used to load <code>Gltf</code> files</li>
<li><code>UiFormat</code> - used to load UI components in a specialised DSL format.</li>
</ul>
<p>For an example of a <code>Prefab</code> in <code>ron</code> format, look at <code>examples/assets/prefab/example.ron</code>. The
<code>PrefabData</code> for this is:</p>
<pre><code class="language-rust ignore">(
    Option&lt;GraphicsPrefab&lt;ObjFormat, TextureFormat&gt;&gt;,
    Option&lt;Transform&gt;,
    Option&lt;Light&gt;,
    Option&lt;CameraPrefab&gt;,
)
</code></pre>
<p>For a more advanced example, and also a custom <code>PrefabData</code> implementation, look at the <code>gltf</code> example
and <code>examples/assets/prefab/puffy_scene.ron</code>.</p>
<a class="header" href="#glossary" id="glossary"><h1>Glossary</h1></a>
<a class="header" href="#data-driven-design" id="data-driven-design"><h2>Data-driven design</h2></a>
<p>Describes a program that has its logic defined largely in data rather than in
compiled code. Ideally, this would permit the user to edit their code and
resources using offline tools and have the program hot-reload the changes at
run-time for instant feedback without the need for recompilation. The bare
minimum qualification for a data-driven program is the ability to read external
content (text files, scripts, byte streams) and mutate its behavior accordingly.</p>
<a class="header" href="#data-oriented-programming" id="data-oriented-programming"><h2>Data-oriented programming</h2></a>
<p>Not to be confused with data-driven design, data-oriented programming is a
programming paradigm, like object-oriented programming (OOP) or procedural
programming. Where OOP focuses on modeling a problem in terms of interacting
objects, and procedural programming tries to model a problem in terms of
sequential or recursive steps or procedures, data-oriented programming shifts
the focus towards the data being operated on: the data type, its memory layout,
how it will be processed. Software written in a data-oriented manner tends
toward high-throughput pipelining, modularity, separation of concerns, and
massive parallelism. If architected correctly, data-oriented software can be
very cache-friendly and easy to scale on systems with multiple cores.</p>
<blockquote>
<p>Note: Data-oriented programming does not necessarily imply that a program is
data-driven. Data-driven behavior can be implemented with any programming
approach you like.</p>
</blockquote>
<a class="header" href="#entity-component-system-ecs-model" id="entity-component-system-ecs-model"><h2>Entity-component-system (ECS) model</h2></a>
<p>Describes a game programming design pattern invented as a reaction to the
deep-rooted problems with using <em>inheritance</em> (is-a relationship) to represent
game objects, including the <a href="https://en.wikipedia.org/wiki/Multiple_inheritance#The_diamond_problem">deadly diamond of death</a> and <a href="https://en.wikipedia.org/wiki/God_object">god objects</a>.
The inheritance-based approach was especially common in the game industry during
the 1990's and early 2000's.</p>
<p>This alternative model makes use of <em>composition</em> (has-a relationship) instead
of inheritance to represent objects in the game world, flattening the hierarchy
and eliminating the problems above, while increasing flexibility. The holistic
ECS approach is broken into three key pieces:</p>
<ol>
<li><em>Entity</em>: Represents a single object in the game world. Has no functionality
on its own. The world owns a collection of entities (either in a flat list or
a hierarchy). Each entity has a unique identifier or name, for the sake of
ease of use.</li>
<li><em>Component</em>: A plain-old-data structure that describes a certain trait an
entity can have. Can be &quot;attached&quot; to entities to grant them certain
abilities, e.g. a <code>Light</code> component contains parameters to make an entity
glow, or a <code>Collidable</code> component can grant an entity collision detection
properties. These components <em>do not</em> have any logic. They contain only data.</li>
<li><em>System</em>: This is where the magic happens! Systems are centralized game engine
subsystems that perform a specific function, such as rendering, physics, audio,
etc. Every frame, they process each entity in the game world looking for
components that are relevant to them, reading their contents, and performing
actions. For example, a <code>Rendering</code> system could search for all entities that have
<code>Light</code>, <code>Mesh</code>, or <code>Emitter</code> components and draw them to the screen.</li>
</ol>
<p>This approach could potentially be stretched to fit the model-view-controller
(MVC) paradigm popular in GUI and Web development circles: entities and
components together represent the model, and systems represent either views
(<code>Rendering</code>, <code>Audio</code>) or controllers (<code>Input</code>, <code>AI</code>, <code>Physics</code>), depending on
their purpose.</p>
<p>Another great advantage of the ECS model is the ability to rapidly prototype
a game simply by describing objects' characteristics in terms of creating
entities and attaching components to them, with very little game code involved.
And all of this data can be easily serialized or de-serialized into a
human-friendly plain text format like <a href="https://github.com/ron-rs/ron">RON</a> (Json derivative).</p>
<p>For more detailed explanations of entity-component-system designs, please
<a href="https://www.reddit.com/r/rust/comments/43p2fq/this_week_in_amethyst_3/czkc4hj">see this great post on Reddit</a> and <a href="http://gamedev.stackexchange.com/questions/31473/what-is-the-role-of-systems-in-a-component-based-entity-architecture/31491#31491">this Stack Overflow answer</a>.</p>
<a class="header" href="#appendix-a-config-files" id="appendix-a-config-files"><h1>Appendix A: Config Files</h1></a>
<p>In the <a href="https://github.com/amethyst/amethyst/tree/master/examples/pong">full Pong example</a>, the paddle sizes, ball sizes, colors, and arena size are all hard-coded
into the implementation. This means that if you want to change any of these, you need to recompile the
project. Wouldn't it be nice to not have to recompile the project each time you wanted to change one or all
of these things?</p>
<p>Luckily, Amethyst uses <a href="https://docs.rs/ron/0.3.0/ron/">RON</a> configuration files and has infrastructure in the form of the
<a href="https://docs.rs/amethyst_config/0.6.0/amethyst_config/trait.Config.html">Config</a> trait to help us implement our own config files.</p>
<a class="header" href="#structure-of-the-config-file" id="structure-of-the-config-file"><h2>Structure of the Config File</h2></a>
<p>The existing example uses the following constants:</p>
<pre><code class="language-rust ignore">const ARENA_HEIGHT: f32 = 100.0;
const ARENA_WIDTH: f32 = 100.0;
const PADDLE_HEIGHT: f32 = 15.0;
const PADDLE_WIDTH: f32 = 2.5;
const PADDLE_VELOCITY: f32 = 75.0;
const PADDLE_COLOUR: [f32; 4] = [0.0, 0.0, 1.0, 1.0];

const BALL_VELOCITY_X: f32 = 75.0;
const BALL_VELOCITY_Y: f32 = 50.0;
const BALL_RADIUS: f32 = 2.5;
const BALL_COLOUR: [f32; 4] = [1.0, 0.0, 0.0, 1.0];
</code></pre>
<p>to specify the look of the game. We want to replace this with something more flexible in the form of a config
file. To start, let's create a new file, <code>config.rs</code>, to hold our configuration structures. Add the following
<code>use</code> statements to the top of this file:</p>
<pre><code class="language-rust ignore">use std::path::Path;

use amethyst::config::Config;
</code></pre>
<p>For this project, we'll be placing a <code>config.ron</code> file in the same location as the <code>display_config.ron</code> and
<code>input.ron</code> files (likely the <code>resources/</code> folder).</p>
<a class="header" href="#chapters-1" id="chapters-1"><h2>Chapters</h2></a>
<ul>
<li><a href="./a_config_files/arena_config.html">Adding an ArenaConfig</a></li>
<li><a href="./a_config_files/ball_config.html">Adding a Ball Config</a></li>
<li><a href="./a_config_files/paddle_configs.html">Adding Paddle Configs</a></li>
</ul>
<a class="header" href="#adding-an-arena-config" id="adding-an-arena-config"><h1>Adding an Arena Config</h1></a>
<p>To begin with, let's make the <code>Arena</code> dimensions configurable. Add this structure to a new file <code>config.rs</code>.</p>
<pre><code class="language-rust ignore">#[derive(Debug, Deserialize, Serialize)]
struct ArenaConfig {
    pub height: f32,
    pub width: f32,
}

impl Default for ArenaConfig {
    fn default() -&gt; Self {
        ArenaConfig {
            height: 100.0,
            width: 100.0,
        }
    }
}
</code></pre>
<p>The default values match the values used in the full example, so if we don't use a config file things will
look just like the Pong example. Another option would be to use <a href="https://serde.rs/attr-default.html"><code>[#serde(default)]</code></a>, which allows
you to set the default value of a field if that field is not present in the config file. This is different
than the <a href="https://doc.rust-lang.org/std/default/trait.Default.html"><code>Default</code></a> trait in that you can set default values for some fields while requiring others
be present. For now though, let's just use the <code>Default</code> trait.</p>
<a class="header" href="#adding-the-config-to-the-world" id="adding-the-config-to-the-world"><h2>Adding the Config to the World</h2></a>
<p>Now, in <code>main.rs</code>, add the following lines:</p>
<pre><code class="language-rust ignore">use config::ArenaConfig;
</code></pre>
<p>We'll need to load the config at startup, so let's add this to the <code>run</code> function in <code>main.rs</code></p>
<pre><code class="language-rust ignore">let arena_config = ArenaConfig::load(&amp;config);
</code></pre>
<p>Now that we have loaded our config, we want to add it to the world so other modules can access
it. We do this by adding the config as a resource during <code>Application</code> creation:</p>
<pre><code class="language-rust ignore">    .with_resource(arena_config)
    .with_bundle(PongBundle::default())?
</code></pre>
<p>Now for the difficult part: replacing every use of <code>ARENA_WIDTH</code> and <code>ARENA_HEIGHT</code> with our config object.
First, let's change our initialisation steps in <code>pong.rs</code>.</p>
<p>Add the following line to the top of <code>pong.rs</code>:</p>
<pre><code class="language-rust ignore">use config::ArenaConfig;
</code></pre>
<p>Now, in the <code>initialise_paddles()</code> function, add the following lines after the initialisation of the
<code>left_transform</code> and <code>right_transform</code>.</p>
<pre><code class="language-rust ignore">let (arena_height, arena_width) = {
    let config = &amp;world.read_resource::&lt;ArenaConfig&gt;();
    (config.height, config.width)
};
</code></pre>
<p>Now replace all references to <code>ARENA_HEIGHT</code> with <code>arena_height</code> and all references to <code>ARENA_WIDTH</code> with
<code>arena_width</code>. Do this for each initialisation function in <code>pong.rs</code>.</p>
<a class="header" href="#accessing-config-files-from-systems" id="accessing-config-files-from-systems"><h2>Accessing Config Files from Systems</h2></a>
<p>It is actually simpler to access a Config file from a system than via the <code>World</code> directly. To access
it in the <code>System</code>'s <code>run()</code> function, add it to the <code>SystemData</code> type. This is what the <code>BounceSystem</code> looks
like when it wants to access the <code>ArenaConfig</code>.</p>
<pre><code class="language-rust ignore">use config::ArenaConfig;
...
type SystemData = (
    WriteStorage&lt;'s, Ball&gt;,
    ReadStorage&lt;'s, Paddle&gt;,
    ReadStorage&lt;'s, Transform&gt;,
    Read&lt;'s, AssetStorage&lt;Source&gt;&gt;,
    ReadExpect&lt;'s, Sounds&gt;,
    Read&lt;'s, Option&lt;Output&gt;&gt;,
    Read&lt;'s, ArenaConfig&gt;,
);
...
fn run(&amp;mut self, 
       (mut balls, paddles, transforms, storage, sounds, audio_output, arena_config): SystemData) {
</code></pre>
<p>Now, in the <code>run()</code> function, replace the reference to <code>ARENA_HEIGHT</code> with <code>arena_config.height</code>.</p>
<p>Add <code>Read&lt;'s, ArenaConfig&gt;</code> to the <code>WinnerSystem</code> and <code>PaddleSystem</code> as well, replacing the reference to
<code>ARENA_WIDTH</code> with <code>arena_config.width</code>.</p>
<a class="header" href="#making-configron" id="making-configron"><h2>Making <code>config.ron</code></h2></a>
<p>Now for the final part: actually creating our <code>config.ron</code> file. This will be very simple right now, and
expand as we add more configurable items. For now, just copy and paste the following into a new file. Feel
free to modify the height and width if you want.</p>
<pre><code class="language-ignore">arena: (
    height: 100.0,
    width: 100.0,
)
</code></pre>
<a class="header" href="#adding-a-ball-config" id="adding-a-ball-config"><h1>Adding a Ball Config</h1></a>
<p>For simplicity, we will wrap all of our Config objects into a single <code>PongConfig</code> object backed by a single
<code>config.ron</code> file, but know that you can just as easily keep them in separate files and read from each file
separately.</p>
<p>To prepare for our <code>BallConfig</code>, add the following line to the top of <code>config.rs</code>:</p>
<pre><code class="language-rust ignore">use amethyst::core::cgmath::Vector2;
</code></pre>
<p>The <code>BallConfig</code> will replace the <code>BALL_VELOCITY_X</code>, <code>BALL_VELOCITY_Y</code>, <code>BALL_RADIUS</code>, and <code>BALL_COLOR</code>
variables. We'll use a <a href="https://docs.rs/cgmath/0.16.0/cgmath/struct.Vector2.html"><code>Vector2</code></a> to store the velocity for simplicity and to demonstrate how to add
a non-trivial data type to a RON file. The <code>BALL_COLOR</code> was originally an array, but [Serde][serde] and RON
handle arrays as tuples, so it will read in a tuple and convert the colour values to an array if needed by a
particular function (e.g., in <code>pong.rs</code>).</p>
<pre><code class="language-rust ignore">#[derive(Debug, Deserialize, Serialize)]
pub struct BallConfig {
    pub velocity: Vector2&lt;f32&gt;,
    pub radius: f32,
    pub colour: (f32, f32, f32, f32),
}
</code></pre>
<p>We'll also add the <code>Default</code> trait to this config that will match what the full example uses.</p>
<pre><code class="language-rust ignore">impl Default for BallConfig {
    fn default() -&gt; Self {
        BallConfig {
            velocity: Vector2::new(75.0, 50.0),
            radius: 2.5,
            colour: (1.0, 0.0, 0.0, 1.0),
        }
    }
}
</code></pre>
<p>Still in <code>config.rs</code>, add the following structure definition at the very bottom. This structure will be
backed by the whole <code>config.ron</code> file.</p>
<pre><code class="language-rust ignore">#[derive(Debug, Default, Deserialize, Serialize)]
pub struct PongConfig {
    pub arena: ArenaConfig,
    pub ball: BallConfig,
}
</code></pre>
<a class="header" href="#replacing-ball-constants" id="replacing-ball-constants"><h2>Replacing Ball Constants</h2></a>
<p>Now we need to replace our usage of the <code>BALL_*</code> constants with our new <code>BallConfig</code>.</p>
<p>We use these values in <code>pong.rs</code> in the <code>initialise_ball()</code> function, so the substition is even simpler than
the <code>ArenaConfig</code>.</p>
<p>In <code>pong.rs</code>, underneath our loading of the <code>ArenaConfig</code>, add the following lines</p>
<pre><code class="language-rust ignore">let (velocity_x, velocity_y, radius, colour) = {
    let config = world.read_resource::&lt;BallConfig&gt;();
    let c: [f32; 4] = [
        config.colour.0,
        config.colour.1,
        config.colour.2,
        config.colour.3,
    ];
    (config.velocity.x, config.velocity.y, config.radius, c)
};
</code></pre>
<p>Our functions expect a <code>[f32; 4]</code> array, so we had to convert the tuple to an array. This is relatively
simple to do, but for more complex arrays it might be worth it to add a function to the <code>impl BallConfig</code> to
avoid duplicating this effort.</p>
<p>Now, within the <code>initialise_ball</code> function, replace <code>BALL_VELOCITY_X</code> with <code>velocity_x</code>, <code>BALL_VELOCITY_Y</code>
with <code>velocity_y</code>, <code>BALL_RADIUS</code> with <code>radius</code>, and <code>BALL_COLOR</code> with <code>color</code>.</p>
<a class="header" href="#modifying-the-initialisation" id="modifying-the-initialisation"><h2>Modifying the initialisation</h2></a>
<p>Now we will modify our application initialisation. We don't want everyone to always access all the config files, so we need to
add each resource separately so systems can use only what they want.</p>
<p>First, we need to change what <code>main.rs</code> is using. Change</p>
<pre><code class="language-rust ignore">use config::ArenaConfig;
</code></pre>
<p>to</p>
<pre><code class="language-rust ignore">use config::PongConfig;
</code></pre>
<p>Now, modify the <code>run()</code> function, from</p>
<pre><code class="language-rust ignore">let arena_config = ArenaConfig::load(&amp;config);
[..]
    .with_resource(arena_config)
    .with_bundle(PongBundle::default())?
</code></pre>
<p>to</p>
<pre><code class="language-rust ignore">let pong_config = PongConfig::load(&amp;config);
[..]
    .with_resource(pong_config.arena)
    .with_resource(pong_config.ball)
    .with_bundle(PongBundle::default())?
</code></pre>
<a class="header" href="#adding-the-ballconfig-to-configron" id="adding-the-ballconfig-to-configron"><h2>Adding the BallConfig to <code>config.ron</code></h2></a>
<p>Now we need to modify our configuration file to allow multiple structures to be included. This is actually
very easy with RON; we just add an additional level of nesting.</p>
<pre><code class="language-ignore">(
    arena: (
        height: 100.0,
        width: 100.0,
    ),
    ball: (
        velocity: Vector2(
            x: 75.0,
            y: 50.0,
        ),
        radius: 2.5,
        color: (1.0, 0.647, 0.0, 1.0),
    ),
)
</code></pre>
<p>This configuration sets the ball to be orange, while retaining the same size and velocity as the original
example.</p>
<a class="header" href="#adding-paddle-configs" id="adding-paddle-configs"><h1>Adding Paddle Configs</h1></a>
<p>We're finally going to add a configuration struct for our Paddles. Because our Pong clone supports two
players, we should let them configure each separately. Add the following to the <code>config.rs</code> file:</p>
<pre><code class="language-rust ignore">#[derive(Debug, Deserialize, Serialize)]
pub struct PaddleConfig {
    pub height: f32,
    pub width: f32,
    pub velocity: f32,
    pub colour: (f32, f32, f32, f32),
}

impl Default for PaddleConfig {
    fn default() -&gt; Self {
        PaddleConfig {
            height: 15.0,
            width: 2.5,
            velocity: 75.0,
            color: (0.0, 0.0, 1.0, 1.0),
        }
    }
}
</code></pre>
<p>Just like the <code>BallConfig</code>, we need to read in the colour as a tuple instead of an array.</p>
<p>Now, to allow us to have two separate <code>PaddleConfig</code>s, we will wrap them in a bigger structure as follows:</p>
<pre><code class="language-rust ignore">#[derive(Debug, Default, Deserialize, Serialize)]
pub struct PaddlesConfig {
    pub left: PaddleConfig,
    pub right: PaddleConfig,
}
</code></pre>
<p>Now we need to add the <code>PaddlesConfig</code> to our <code>PongConfig</code> as shown below</p>
<pre><code class="language-rust ignore">pub struct PongConfig {
    pub arena: ArenaConfig,
    pub ball: BallConfig,
    pub paddles: PaddlesConfig,
}
</code></pre>
<p>and modify the <code>main.rs</code>'s <code>run()</code> function to add our <code>PaddleConfig</code>s.</p>
<pre><code class="language-rust ignore">    .with_resource(pong_config.arena)
    .with_resource(pong_config.ball)
    .with_resource(pong_config.paddles)
    .with_bundle(PongBundle::default())?
</code></pre>
<p>We add the <code>PaddlesConfig</code> to the <code>World</code>, rather than as separate <code>left</code> and <code>right</code> configurations because
<code>System</code>s can only access resources with ID 0. Any resource added using <a href="https://docs.rs/specs/0.12.0/specs/struct.World.html#method.add_resource"><code>World::add_resource</code></a>
is added using a default ID of 0. You must use <a href="https://docs.rs/specs/0.12.0/specs/struct.World.html#method.add_resource_with_id"><code>World::add_resource_with_id</code></a> to add multiple
resources of the same type, but then the <code>System</code>s cannot properly differentiate between them.</p>
<a class="header" href="#replacing-constants-with-configs" id="replacing-constants-with-configs"><h2>Replacing Constants with Configs</h2></a>
<p>Replacing all instances of <code>PADDLE_*</code> will be similar to the <code>BallConfig</code>, as we only use those values for
creating the paddle entities. However, we will need to separate the <code>PaddlesConfig</code> into <code>left</code> and <code>right</code>.
To avoid issues with the borrow checker, we read the <code>PaddlesConfig</code> once and copy all of the values,
unwrapping them in one big assignment statement.
In <code>initialise_paddles()</code> in <code>pong.rs</code>, add this code below reading the <code>ArenaConfig</code>.</p>
<pre><code class="language-rust ignore">let (
    left_height,
    left_width,
    left_velocity,
    left_colour,
    right_height,
    right_width,
    right_velocity,
    right_colour,
) = {
    let config = &amp;world.read_resource::&lt;PaddlesConfig&gt;();
    let cl: [f32; 4] = [
        config.left.colour.0,
        config.left.colour.1,
        config.left.colour.2,
        config.left.colour.3,
    ];
    let cr: [f32; 4] = [
        config.right.colour.0,
        config.right.colour.1,
        config.right.colour.2,
        config.right.colour.3,
    ];
    (
        config.left.height,
        config.left.width,
        config.left.velocity,
        cl,
        config.right.height,
        config.right.width,
        config.right.velocity,
        cr,
    )
};
</code></pre>
<p>Now, within this function, replace</p>
<pre><code class="language-rust ignore">let y = (arena_height - PADDLE_HEIGHT) / 2.0;
</code></pre>
<p>with</p>
<pre><code class="language-rust ignore">let left_y = (arena_height - left_height) / 2.0;
let right_y = (arena_height - right_height) / 2.0;
</code></pre>
<p>You will also need to repeat the calls to <code>create_mesh</code> and
<code>create_colour_material()</code> so that you have a left and right mesh and left
and right colour.</p>
<p>Now, use the left- and right-specific values in  the <code>world.create_entity()</code>
calls.</p>
<a class="header" href="#modifying-configron" id="modifying-configron"><h2>Modifying <code>config.ron</code></h2></a>
<p>Now for the final modification of our <code>config.ron</code> file. For fun, let's make the right paddle yellow and
keep the left paddle blue so the final <code>config.ron</code> file will be as follows:</p>
<pre><code class="language-ignore">(
    arena: (
        height: 100.0,
        width: 100.0,
    ),
    ball: (
        velocity: Vector2(
            x: 75.0,
            y: 50.0,
        ),
        radius: 2.5,
        color: (1.0, 0.647, 0.0, 1.0),
    ),
    paddles: (
        left: (
            height: 15.0,
            width: 2.5,
            velocity: 75.0,
            color: (0.0, 0.0, 1.0, 1.0),
        ),
        right: (
            height: 15.0,
            width: 2.5,
            velocity: 75.0,
            color: (0.0, 1.0, 1.0, 1.0),
        ),
    )
)
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
